
### Comparando com backup: backup_2025-07-03_00-32-28

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_00-32-28/app.py
@@ -1,18 +1,18 @@
+import pygame

+import sys

 import os

 import shutil

 from datetime import datetime

+from background import draw_background, WIDTH, HEIGHT  # importa tudo

 

+# === Função de backup ===

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 

@@ -21,23 +21,63 @@
     print(f"Backup criado em: {pasta_backup}")

     return pasta_backup

 

+# === Código do jogo ===

+pygame.init()

+

+screen = pygame.display.set_mode((WIDTH, HEIGHT))

+pygame.display.set_caption("Jogo Clicker Simples")

+

+FONT = pygame.font.SysFont(None, 48)

+BUTTON_COLOR = (70, 130, 180)

+BUTTON_HOVER_COLOR = (100, 160, 210)

+TEXT_COLOR = (255, 255, 255)

+

+def draw_button(screen, rect, text, mouse_pos):

+    color = BUTTON_HOVER_COLOR if rect.collidepoint(mouse_pos) else BUTTON_COLOR

+    pygame.draw.rect(screen, color, rect)

+    txt_surf = FONT.render(text, True, TEXT_COLOR)

+    txt_rect = txt_surf.get_rect(center=rect.center)

+    screen.blit(txt_surf, txt_rect)

+

 def main():

-    # Define os caminhos

+    # Backup automático ao iniciar

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

     pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    score = 0

+    clock = pygame.time.Clock()

+    button_rect = pygame.Rect(WIDTH//2 - 75, HEIGHT//2 - 40, 150, 80)

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        draw_background(screen)

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button_rect.collidepoint(event.pos):

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_button(screen, button_rect, "Clique!", mouse_pos)

+

+        score_surf = FONT.render(f"Pontos: {score}", True, TEXT_COLOR)

+        screen.blit(score_surf, (20, 20))

+

+        info_surf = pygame.font.SysFont(None, 24).render("Pressione R para resetar", True, TEXT_COLOR)

+        screen.blit(info_surf, (20, HEIGHT - 30))

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



### Comparando com backup: backup_2025-07-03_00-32-49

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_00-32-49/app.py
@@ -1,18 +1,18 @@
+import pygame

+import sys

 import os

 import shutil

 from datetime import datetime

+from background import draw_background, WIDTH, HEIGHT  # importa tudo

 

+# === Função de backup ===

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 

@@ -21,23 +21,63 @@
     print(f"Backup criado em: {pasta_backup}")

     return pasta_backup

 

+# === Código do jogo ===

+pygame.init()

+

+screen = pygame.display.set_mode((WIDTH, HEIGHT))

+pygame.display.set_caption("Jogo Clicker Simples")

+

+FONT = pygame.font.SysFont(None, 48)

+BUTTON_COLOR = (70, 130, 180)

+BUTTON_HOVER_COLOR = (100, 160, 210)

+TEXT_COLOR = (255, 255, 255)

+

+def draw_button(screen, rect, text, mouse_pos):

+    color = BUTTON_HOVER_COLOR if rect.collidepoint(mouse_pos) else BUTTON_COLOR

+    pygame.draw.rect(screen, color, rect)

+    txt_surf = FONT.render(text, True, TEXT_COLOR)

+    txt_rect = txt_surf.get_rect(center=rect.center)

+    screen.blit(txt_surf, txt_rect)

+

 def main():

-    # Define os caminhos

+    # Backup automático ao iniciar

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

     pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    score = 0

+    clock = pygame.time.Clock()

+    button_rect = pygame.Rect(WIDTH//2 - 75, HEIGHT//2 - 40, 150, 80)

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        draw_background(screen)

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button_rect.collidepoint(event.pos):

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_button(screen, button_rect, "Clique!", mouse_pos)

+

+        score_surf = FONT.render(f"Pontos: {score}", True, TEXT_COLOR)

+        screen.blit(score_surf, (20, 20))

+

+        info_surf = pygame.font.SysFont(None, 24).render("Pressione R para resetar", True, TEXT_COLOR)

+        screen.blit(info_surf, (20, HEIGHT - 30))

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



### Comparando com backup: backup_2025-07-03_00-35-34

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_00-35-34/app.py
@@ -1,18 +1,18 @@
+import pygame

+import sys

 import os

 import shutil

 from datetime import datetime

+from background import draw_background, WIDTH, HEIGHT  # importa tudo

 

+# === Função de backup ===

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 

@@ -21,23 +21,63 @@
     print(f"Backup criado em: {pasta_backup}")

     return pasta_backup

 

+# === Código do jogo ===

+pygame.init()

+

+screen = pygame.display.set_mode((WIDTH, HEIGHT))

+pygame.display.set_caption("Jogo Clicker Simples")

+

+FONT = pygame.font.SysFont(None, 48)

+BUTTON_COLOR = (70, 130, 180)

+BUTTON_HOVER_COLOR = (100, 160, 210)

+TEXT_COLOR = (255, 255, 255)

+

+def draw_button(screen, rect, text, mouse_pos):

+    color = BUTTON_HOVER_COLOR if rect.collidepoint(mouse_pos) else BUTTON_COLOR

+    pygame.draw.rect(screen, color, rect)

+    txt_surf = FONT.render(text, True, TEXT_COLOR)

+    txt_rect = txt_surf.get_rect(center=rect.center)

+    screen.blit(txt_surf, txt_rect)

+

 def main():

-    # Define os caminhos

+    # Backup automático ao iniciar

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    score = 0

+    clock = pygame.time.Clock()

+    button_rect = pygame.Rect(WIDTH//2 - 75, HEIGHT//2 - 40, 150, 80)

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        draw_background(screen)

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button_rect.collidepoint(event.pos):

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_button(screen, button_rect, "Clique!", mouse_pos)

+

+        score_surf = FONT.render(f"Pontos: {score}", True, TEXT_COLOR)

+        screen.blit(score_surf, (20, 20))

+

+        info_surf = pygame.font.SysFont(None, 24).render("Pressione R para resetar", True, TEXT_COLOR)

+        screen.blit(info_surf, (20, HEIGHT - 30))

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



### Comparando com backup: backup_2025-07-03_00-37-23

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_00-37-23/app.py
@@ -1,43 +1,67 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup  # importa a função do backup.py

+from background import draw_background, WIDTH, HEIGHT  # seu background

 

 def main():

-    # Define os caminhos

+    # Define as pastas do projeto e backup

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"  # ajuste para dentro do seu repo!

 

-    # Faz backup no início do app

+    # Faz backup ao iniciar

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Jogo Clicker Simples")

+

+    FONT = pygame.font.SysFont(None, 48)

+    BUTTON_COLOR = (70, 130, 180)

+    BUTTON_HOVER_COLOR = (100, 160, 210)

+    TEXT_COLOR = (255, 255, 255)

+

+    def draw_button(screen, rect, text, mouse_pos):

+        color = BUTTON_HOVER_COLOR if rect.collidepoint(mouse_pos) else BUTTON_COLOR

+        pygame.draw.rect(screen, color, rect)

+        txt_surf = FONT.render(text, True, TEXT_COLOR)

+        txt_rect = txt_surf.get_rect(center=rect.center)

+        screen.blit(txt_surf, txt_rect)

+

+    score = 0

+    clock = pygame.time.Clock()

+    button_rect = pygame.Rect(WIDTH//2 - 75, HEIGHT//2 - 40, 150, 80)

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        draw_background(screen)

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button_rect.collidepoint(event.pos):

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_button(screen, button_rect, "Clique!", mouse_pos)

+

+        score_surf = FONT.render(f"Pontos: {score}", True, TEXT_COLOR)

+        screen.blit(score_surf, (20, 20))

+

+        info_surf = pygame.font.SysFont(None, 24).render("Pressione R para resetar", True, TEXT_COLOR)

+        screen.blit(info_surf, (20, HEIGHT - 30))

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_00-37-23/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



### Comparando com backup: backup_2025-07-03_00-38-51

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_00-38-51/app.py
@@ -1,43 +1,67 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup  # importa a função do backup.py

+from background import draw_background, WIDTH, HEIGHT  # seu background

 

 def main():

-    # Define os caminhos

+    # Define as pastas do projeto e backup

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"  # ajuste para dentro do seu repo!

 

-    # Faz backup no início do app

+    # Faz backup ao iniciar

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Jogo Clicker Simples")

+

+    FONT = pygame.font.SysFont(None, 48)

+    BUTTON_COLOR = (70, 130, 180)

+    BUTTON_HOVER_COLOR = (100, 160, 210)

+    TEXT_COLOR = (255, 255, 255)

+

+    def draw_button(screen, rect, text, mouse_pos):

+        color = BUTTON_HOVER_COLOR if rect.collidepoint(mouse_pos) else BUTTON_COLOR

+        pygame.draw.rect(screen, color, rect)

+        txt_surf = FONT.render(text, True, TEXT_COLOR)

+        txt_rect = txt_surf.get_rect(center=rect.center)

+        screen.blit(txt_surf, txt_rect)

+

+    score = 0

+    clock = pygame.time.Clock()

+    button_rect = pygame.Rect(WIDTH//2 - 75, HEIGHT//2 - 40, 150, 80)

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        draw_background(screen)

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button_rect.collidepoint(event.pos):

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_button(screen, button_rect, "Clique!", mouse_pos)

+

+        score_surf = FONT.render(f"Pontos: {score}", True, TEXT_COLOR)

+        screen.blit(score_surf, (20, 20))

+

+        info_surf = pygame.font.SysFont(None, 24).render("Pressione R para resetar", True, TEXT_COLOR)

+        screen.blit(info_surf, (20, HEIGHT - 30))

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_00-38-51/background.py
@@ -1,15 +1,22 @@
 import pygame

+import random

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadradinho

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

+    # Paleta de cores claras (tons pastel)

+    pastel_colors = [

+        (200, 230, 201),  # verde claro

+        (255, 224, 178),  # laranja claro

+        (255, 205, 210),  # rosa claro

+        (187, 222, 251),  # azul claro

+        (255, 249, 196),  # amarelo claro

+        (197, 225, 165),  # verde limão claro

+    ]

 

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    for y in range(0, HEIGHT, TILE_SIZE):

+        for x in range(0, WIDTH, TILE_SIZE):

+            color = random.choice(pastel_colors)

+            rect = pygame.Rect(x, y, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_00-38-51/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



### Comparando com backup: backup_2025-07-03_00-39-36

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_00-39-36/app.py
@@ -1,43 +1,67 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup  # importa a função do backup.py

+from background import draw_background, WIDTH, HEIGHT  # seu background

 

 def main():

-    # Define os caminhos

+    # Define as pastas do projeto e backup

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"  # ajuste para dentro do seu repo!

 

-    # Faz backup no início do app

+    # Faz backup ao iniciar

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Jogo Clicker Simples")

+

+    FONT = pygame.font.SysFont(None, 48)

+    BUTTON_COLOR = (70, 130, 180)

+    BUTTON_HOVER_COLOR = (100, 160, 210)

+    TEXT_COLOR = (255, 255, 255)

+

+    def draw_button(screen, rect, text, mouse_pos):

+        color = BUTTON_HOVER_COLOR if rect.collidepoint(mouse_pos) else BUTTON_COLOR

+        pygame.draw.rect(screen, color, rect)

+        txt_surf = FONT.render(text, True, TEXT_COLOR)

+        txt_rect = txt_surf.get_rect(center=rect.center)

+        screen.blit(txt_surf, txt_rect)

+

+    score = 0

+    clock = pygame.time.Clock()

+    button_rect = pygame.Rect(WIDTH//2 - 75, HEIGHT//2 - 40, 150, 80)

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        draw_background(screen)

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button_rect.collidepoint(event.pos):

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_button(screen, button_rect, "Clique!", mouse_pos)

+

+        score_surf = FONT.render(f"Pontos: {score}", True, TEXT_COLOR)

+        screen.blit(score_surf, (20, 20))

+

+        info_surf = pygame.font.SysFont(None, 24).render("Pressione R para resetar", True, TEXT_COLOR)

+        screen.blit(info_surf, (20, HEIGHT - 30))

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_00-39-36/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_00-39-36/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



### Comparando com backup: backup_2025-07-03_00-45-15

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_00-45-15/app.py
@@ -1,43 +1,55 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

 

 def main():

-    # Define os caminhos

+    # Pastas do projeto e backup

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"  # ajuste seu caminho

 

-    # Faz backup no início do app

+    # Faz backup ao iniciar

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Jogo Clicker Simples")

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR = (255, 255, 255)

+

+    score = 0

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        draw_background(screen)

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            # Note que o clique no botão animado agora vai ser tratado no seu arquivo button.py

+            # Se quiser, pode importar e usar a classe AnimatedButton e tratar clique aqui

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        # Aqui só mostramos a pontuação e texto explicativo

+        score_surf = FONT.render(f"Pontos: {score}", True, TEXT_COLOR)

+        screen.blit(score_surf, (20, 20))

+

+        info_surf = pygame.font.SysFont(None, 24).render("Pressione R para resetar", True, TEXT_COLOR)

+        screen.blit(info_surf, (20, HEIGHT - 30))

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_00-45-15/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_00-45-15/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_00-45-15: button.py

### Comparando com backup: backup_2025-07-03_00-46-43

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_00-46-43/app.py
@@ -1,43 +1,61 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

 

 def main():

-    # Define os caminhos

+    # Pastas do projeto e backup

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"  # ajuste seu caminho

 

-    # Faz backup no início do app

+    # Faz backup ao iniciar

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Jogo Clicker com botão animado")

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR = (255, 255, 255)

+

+    # Cria o botão animado no centro da tela

+    button = AnimatedButton(WIDTH//2 - 75, HEIGHT//2 - 40, 150, 80,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score = 0

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        score_surf = FONT.render(f"Pontos: {score}", True, TEXT_COLOR)

+        screen.blit(score_surf, (20, 20))

+

+        info_surf = pygame.font.SysFont(None, 24).render("Pressione R para resetar", True, TEXT_COLOR)

+        screen.blit(info_surf, (20, HEIGHT - 30))

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_00-46-43/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_00-46-43/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_00-46-43: button.py

### Comparando com backup: backup_2025-07-03_00-48-45

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_00-48-45/app.py
@@ -1,43 +1,61 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

 

 def main():

-    # Define os caminhos

+    # Pastas do projeto e backup

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"  # ajuste seu caminho

 

-    # Faz backup no início do app

+    # Faz backup ao iniciar

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Jogo Clicker com botão animado")

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR = (255, 255, 255)

+

+    # Cria o botão animado no centro da tela

+    button = AnimatedButton(WIDTH//2 - 75, HEIGHT//2 - 40, 150, 80,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score = 0

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        score_surf = FONT.render(f"Pontos: {score}", True, TEXT_COLOR)

+        screen.blit(score_surf, (20, 20))

+

+        info_surf = pygame.font.SysFont(None, 24).render("Pressione R para resetar", True, TEXT_COLOR)

+        screen.blit(info_surf, (20, HEIGHT - 30))

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_00-48-45/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_00-48-45/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_00-48-45: button.py

### Comparando com backup: backup_2025-07-03_00-48-59

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_00-48-59/app.py
@@ -1,43 +1,60 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

 

 def main():

-    # Define os caminhos

+    # Pastas do projeto e backup

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"  # ajuste seu caminho

 

-    # Faz backup no início do app

+    # Faz backup ANTES de iniciar o pygame

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Jogo Clicker com botão animado")

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR = (255, 255, 255)

+

+    button = AnimatedButton(WIDTH//2 - 75, HEIGHT//2 - 40, 150, 80,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score = 0

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        score_surf = FONT.render(f"Pontos: {score}", True, TEXT_COLOR)

+        screen.blit(score_surf, (20, 20))

+

+        info_surf = pygame.font.SysFont(None, 24).render("Pressione R para resetar", True, TEXT_COLOR)

+        screen.blit(info_surf, (20, HEIGHT - 30))

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_00-48-59/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_00-48-59/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_00-48-59: button.py

### Comparando com backup: backup_2025-07-03_00-50-02

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_00-50-02/app.py
@@ -1,43 +1,60 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

 

 def main():

-    # Define os caminhos

+    # Pastas do projeto e backup

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"  # ajuste seu caminho

 

-    # Faz backup no início do app

+    # Faz backup ANTES de iniciar o pygame

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Jogo Clicker com botão animado")

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR = (255, 255, 255)

+

+    button = AnimatedButton(WIDTH//2 - 75, HEIGHT//2 - 40, 150, 80,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score = 0

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        score_surf = FONT.render(f"Pontos: {score}", True, TEXT_COLOR)

+        screen.blit(score_surf, (20, 20))

+

+        info_surf = pygame.font.SysFont(None, 24).render("Pressione R para resetar", True, TEXT_COLOR)

+        screen.blit(info_surf, (20, HEIGHT - 30))

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_00-50-02/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_00-50-02/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_00-50-02: button.py

### Comparando com backup: backup_2025-07-03_00-52-20

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_00-52-20/app.py
@@ -1,43 +1,60 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"  # ajuste seu caminho

 

-    # Faz backup no início do app

+    # Faz backup ANTES de iniciar o pygame

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Jogo Clicker com botão animado")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR = (255, 255, 255)

+

+    # Botão centralizado e maior (200x200)

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score = 0

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()  # animação ao clicar

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        score_surf = FONT.render(f"Pontos: {score}", True, TEXT_COLOR)

+        screen.blit(score_surf, (20, 20))

+

+        info_surf = pygame.font.SysFont(None, 24).render("Pressione R para resetar", True, TEXT_COLOR)

+        screen.blit(info_surf, (20, HEIGHT - 30))

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_00-52-20/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_00-52-20/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_00-52-20: button.py

### Comparando com backup: backup_2025-07-03_00-53-19

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_00-53-19/app.py
@@ -1,43 +1,60 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"  # ajuste seu caminho

 

-    # Faz backup no início do app

+    # Faz backup ANTES de iniciar o pygame

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Jogo Clicker com botão animado")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR = (255, 255, 255)

+

+    # Botão centralizado e maior (200x200)

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score = 0

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()  # animação ao clicar

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        score_surf = FONT.render(f"Pontos: {score}", True, TEXT_COLOR)

+        screen.blit(score_surf, (20, 20))

+

+        info_surf = pygame.font.SysFont(None, 24).render("Pressione R para resetar", True, TEXT_COLOR)

+        screen.blit(info_surf, (20, HEIGHT - 30))

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_00-53-19/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_00-53-19/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_00-53-19: button.py

### Comparando com backup: backup_2025-07-03_00-56-36

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_00-56-36/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    SMALL_FONT = pygame.font.SysFont(None, 32)

+    TEXT_COLOR = (255, 255, 255)

+    SCORE_BOX_COLOR = (30, 30, 30)

+    SCORE_BOX_BORDER = (255, 255, 255)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Caixa de pontos com borda

+        box_w, box_h = 220, 60

+        box_x, box_y = 20, 20

+        pygame.draw.rect(screen, SCORE_BOX_COLOR, (box_x, box_y, box_w, box_h))

+        pygame.draw.rect(screen, SCORE_BOX_BORDER, (box_x, box_y, box_w, box_h), 3)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR)

+        screen.blit(score_text, (box_x + 15, box_y + 10))

+

+        info_text = SMALL_FONT.render("Pressione R para resetar", True, TEXT_COLOR)

+        screen.blit(info_text, (box_x + 15, box_y + 35))

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    # Salva o score ao sair

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_00-56-36/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_00-56-36/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_00-56-36: button.py

## Novo arquivo em backup_2025-07-03_00-56-36: score_manager.py

### Comparando com backup: backup_2025-07-03_00-58-42

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_00-58-42/app.py
@@ -1,43 +1,82 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

 

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

+def draw_score_box(screen, x, y, w, h):

+    # Fundo translúcido azul clarinho com quadradinhos sutis

+    s = pygame.Surface((w, h), pygame.SRCALPHA)

+    s.fill((255, 255, 255, 80))  # branco com alpha 80 (transparente)

+    screen.blit(s, (x, y))

 

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+    square_size = 10

+    for i in range(0, w, square_size):

+        for j in range(0, h, square_size):

+            color = (220, 220, 255, 50) if (i//square_size + j//square_size) % 2 == 0 else (200, 200, 230, 50)

+            sq = pygame.Surface((square_size, square_size), pygame.SRCALPHA)

+            sq.fill(color)

+            screen.blit(sq, (x + i, y + j))

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    SMALL_FONT = pygame.font.SysFont(None, 32)

+    TEXT_COLOR = (255, 255, 255)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR)

+        screen.blit(score_text, (box_x + 15, box_y + 10))

+

+        info_text = SMALL_FONT.render("Pressione R para resetar", True, TEXT_COLOR)

+        screen.blit(info_text, (box_x + 15, box_y + 35))

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_00-58-42/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_00-58-42/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_00-58-42: button.py

## Novo arquivo em backup_2025-07-03_00-58-42: score_manager.py

### Comparando com backup: backup_2025-07-03_01-00-54

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-00-54/app.py
@@ -1,43 +1,90 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

 

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

+def draw_score_box(screen, x, y, w, h):

+    # Sombra

+    shadow_color = (0, 0, 0, 50)

+    shadow_surf = pygame.Surface((w, h), pygame.SRCALPHA)

+    pygame.draw.rect(shadow_surf, shadow_color, (5, 5, w, h), border_radius=15)

+    screen.blit(shadow_surf, (x, y))

 

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

+    # Fundo pastel azul claro com cantos arredondados

+    bg_color = (180, 210, 255)

+    pygame.draw.rect(screen, bg_color, (x, y, w, h), border_radius=15)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+    # Quadradinhos sutis (opcional)

+    square_size = 12

+    sq_surf = pygame.Surface((square_size, square_size), pygame.SRCALPHA)

+    color1 = (200, 220, 255, 60)

+    color2 = (170, 200, 250, 60)

+    for i in range(0, w, square_size):

+        for j in range(0, h, square_size):

+            sq_surf.fill(color1 if (i//square_size + j//square_size) % 2 == 0 else color2)

+            screen.blit(sq_surf, (x + i, y + j))

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    SMALL_FONT = pygame.font.SysFont(None, 32)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+    TEXT_COLOR_INFO = (60, 60, 80)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        screen.blit(score_text, (box_x + 15, box_y + 8))

+

+        info_text = SMALL_FONT.render("Pressione R para resetar", True, TEXT_COLOR_INFO)

+        screen.blit(info_text, (box_x + 15, box_y + 35))

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-00-54/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-00-54/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-00-54: button.py

## Novo arquivo em backup_2025-07-03_01-00-54: score_manager.py

### Comparando com backup: backup_2025-07-03_01-01-21

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-01-21/app.py
@@ -1,43 +1,69 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    SMALL_FONT = pygame.font.SysFont(None, 32)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+    TEXT_COLOR_INFO = (60, 60, 80)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        screen.blit(score_text, (box_x + 15, box_y + 8))

+

+        info_text = SMALL_FONT.render("Pressione R para resetar", True, TEXT_COLOR_INFO)

+        screen.blit(info_text, (box_x + 15, box_y + 35))

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-01-21/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-01-21/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-01-21: button.py

## Novo arquivo em backup_2025-07-03_01-01-21: score_manager.py

### Comparando com backup: backup_2025-07-03_01-02-52

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-02-52/app.py
@@ -1,43 +1,64 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        screen.blit(score_text, (box_x + 15, box_y + 15))

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-02-52/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-02-52/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-02-52: button.py

## Novo arquivo em backup_2025-07-03_01-02-52: score_manager.py

### Comparando com backup: backup_2025-07-03_01-03-22

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-03-22/app.py
@@ -1,43 +1,64 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        screen.blit(score_text, (box_x + 15, box_y + 15))

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-03-22/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-03-22/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-03-22: button.py

## Novo arquivo em backup_2025-07-03_01-03-22: score_manager.py

### Comparando com backup: backup_2025-07-03_01-04-11

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-04-11/app.py
@@ -1,43 +1,65 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-04-11/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-04-11/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-04-11: button.py

## Novo arquivo em backup_2025-07-03_01-04-11: score_manager.py

### Comparando com backup: backup_2025-07-03_01-04-20

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-04-20/app.py
@@ -1,43 +1,65 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-04-20/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-04-20/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-04-20: button.py

## Novo arquivo em backup_2025-07-03_01-04-20: score_manager.py

### Comparando com backup: backup_2025-07-03_01-06-31

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-06-31/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH - 320, 50)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-06-31/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-06-31/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-06-31: button.py

## Novo arquivo em backup_2025-07-03_01-06-31: menu.py

## Novo arquivo em backup_2025-07-03_01-06-31: score_manager.py

### Comparando com backup: backup_2025-07-03_01-18-03

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-18-03/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-18-03/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-18-03/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-18-03: button.py

## Novo arquivo em backup_2025-07-03_01-18-03: menu.py

## Novo arquivo em backup_2025-07-03_01-18-03: score_manager.py

### Comparando com backup: backup_2025-07-03_01-21-14

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-21-14/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-21-14/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-21-14/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-21-14: button.py

## Novo arquivo em backup_2025-07-03_01-21-14: menu.py

## Novo arquivo em backup_2025-07-03_01-21-14: score_manager.py

### Comparando com backup: backup_2025-07-03_01-22-35

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-22-35/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-22-35/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-22-35/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-22-35: button.py

## Novo arquivo em backup_2025-07-03_01-22-35: menu.py

## Novo arquivo em backup_2025-07-03_01-22-35: score_manager.py

### Comparando com backup: backup_2025-07-03_01-23-49

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-23-49/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-23-49/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-23-49/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-23-49: button.py

## Novo arquivo em backup_2025-07-03_01-23-49: menu.py

## Novo arquivo em backup_2025-07-03_01-23-49: score_manager.py

### Comparando com backup: backup_2025-07-03_01-26-34

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-26-34/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-26-34/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-26-34/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-26-34: button.py

## Novo arquivo em backup_2025-07-03_01-26-34: menu.py

## Novo arquivo em backup_2025-07-03_01-26-34: score_manager.py

### Comparando com backup: backup_2025-07-03_01-28-22

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-28-22/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-28-22/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-28-22/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-28-22: button.py

## Novo arquivo em backup_2025-07-03_01-28-22: menu.py

## Novo arquivo em backup_2025-07-03_01-28-22: score_manager.py

### Comparando com backup: backup_2025-07-03_01-29-46

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-29-46/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-29-46/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-29-46/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-29-46: button.py

## Novo arquivo em backup_2025-07-03_01-29-46: menu.py

## Novo arquivo em backup_2025-07-03_01-29-46: score_manager.py

### Comparando com backup: backup_2025-07-03_01-30-59

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-30-59/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-30-59/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-30-59/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-30-59: button.py

## Novo arquivo em backup_2025-07-03_01-30-59: menu.py

## Novo arquivo em backup_2025-07-03_01-30-59: score_manager.py

### Comparando com backup: backup_2025-07-03_01-33-48

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-33-48/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-33-48/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-33-48/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-33-48: button.py

## Novo arquivo em backup_2025-07-03_01-33-48: menu.py

## Novo arquivo em backup_2025-07-03_01-33-48: score_manager.py

### Comparando com backup: backup_2025-07-03_01-36-24

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-36-24/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-36-24/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-36-24/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-36-24: button.py

## Novo arquivo em backup_2025-07-03_01-36-24: controles.py

## Novo arquivo em backup_2025-07-03_01-36-24: menu.py

## Novo arquivo em backup_2025-07-03_01-36-24: score_manager.py

### Comparando com backup: backup_2025-07-03_01-37-22

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-37-22/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-37-22/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-37-22/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-37-22: button.py

## Novo arquivo em backup_2025-07-03_01-37-22: controles.py

## Novo arquivo em backup_2025-07-03_01-37-22: menu.py

## Novo arquivo em backup_2025-07-03_01-37-22: score_manager.py

### Comparando com backup: backup_2025-07-03_01-37-39

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-37-39/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-37-39/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-37-39/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-37-39: button.py

## Novo arquivo em backup_2025-07-03_01-37-39: controles.py

## Novo arquivo em backup_2025-07-03_01-37-39: menu.py

## Novo arquivo em backup_2025-07-03_01-37-39: score_manager.py

### Comparando com backup: backup_2025-07-03_01-38-44

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-38-44/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-38-44/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-38-44/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-38-44: button.py

## Novo arquivo em backup_2025-07-03_01-38-44: controles.py

## Novo arquivo em backup_2025-07-03_01-38-44: menu.py

## Novo arquivo em backup_2025-07-03_01-38-44: score_manager.py

### Comparando com backup: backup_2025-07-03_01-41-10

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-41-10/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-41-10/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-41-10/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-41-10: button.py

## Novo arquivo em backup_2025-07-03_01-41-10: controles.py

## Novo arquivo em backup_2025-07-03_01-41-10: menu.py

## Novo arquivo em backup_2025-07-03_01-41-10: score_manager.py

### Comparando com backup: backup_2025-07-03_01-43-37

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-43-37/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()  # Ícone sempre visível

+        config_menu.draw()       # Desenha menu configurações e controles (se visível)

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-43-37/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-43-37/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-43-37: button.py

## Novo arquivo em backup_2025-07-03_01-43-37: controles.py

## Novo arquivo em backup_2025-07-03_01-43-37: menu.py

## Novo arquivo em backup_2025-07-03_01-43-37: score_manager.py

### Comparando com backup: backup_2025-07-03_01-46-38

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-46-38/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()  # Ícone sempre visível

+        config_menu.draw()       # Desenha menu configurações e controles (se visível)

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-46-38/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-46-38/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-46-38: button.py

## Novo arquivo em backup_2025-07-03_01-46-38: controles.py

## Novo arquivo em backup_2025-07-03_01-46-38: menu.py

## Novo arquivo em backup_2025-07-03_01-46-38: score_manager.py

### Comparando com backup: backup_2025-07-03_01-46-53

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-46-53/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()  # Ícone sempre visível

+        config_menu.draw()       # Desenha menu configurações e controles (se visível)

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-46-53/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-46-53/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-46-53: button.py

## Novo arquivo em backup_2025-07-03_01-46-53: controles.py

## Novo arquivo em backup_2025-07-03_01-46-53: menu.py

## Novo arquivo em backup_2025-07-03_01-46-53: score_manager.py

### Comparando com backup: backup_2025-07-03_01-47-09

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-47-09/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, score_manager)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-47-09/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-47-09/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-47-09: button.py

## Novo arquivo em backup_2025-07-03_01-47-09: controles.py

## Novo arquivo em backup_2025-07-03_01-47-09: menu.py

## Novo arquivo em backup_2025-07-03_01-47-09: score_manager.py

### Comparando com backup: backup_2025-07-03_01-47-19

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-47-19/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, score_manager)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-47-19/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-47-19/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-47-19: button.py

## Novo arquivo em backup_2025-07-03_01-47-19: controles.py

## Novo arquivo em backup_2025-07-03_01-47-19: menu.py

## Novo arquivo em backup_2025-07-03_01-47-19: score_manager.py

### Comparando com backup: backup_2025-07-03_01-49-25

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-49-25/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, score_manager)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-49-25/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-49-25/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-49-25: button.py

## Novo arquivo em backup_2025-07-03_01-49-25: controles.py

## Novo arquivo em backup_2025-07-03_01-49-25: menu.py

## Novo arquivo em backup_2025-07-03_01-49-25: score_manager.py

### Comparando com backup: backup_2025-07-03_01-50-27

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-50-27/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, score_manager)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-50-27/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-50-27/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-50-27: button.py

## Novo arquivo em backup_2025-07-03_01-50-27: controles.py

## Novo arquivo em backup_2025-07-03_01-50-27: menu.py

## Novo arquivo em backup_2025-07-03_01-50-27: score_manager.py

### Comparando com backup: backup_2025-07-03_01-51-45

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-51-45/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, score_manager)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-51-45/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-51-45/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-51-45: button.py

## Novo arquivo em backup_2025-07-03_01-51-45: controles.py

## Novo arquivo em backup_2025-07-03_01-51-45: menu.py

## Novo arquivo em backup_2025-07-03_01-51-45: score_manager.py

### Comparando com backup: backup_2025-07-03_01-54-33

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-54-33/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, score_manager)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-54-33/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-54-33/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-54-33: button.py

## Novo arquivo em backup_2025-07-03_01-54-33: controles.py

## Novo arquivo em backup_2025-07-03_01-54-33: menu.py

## Novo arquivo em backup_2025-07-03_01-54-33: score_manager.py

### Comparando com backup: backup_2025-07-03_01-55-43

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-55-43/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-55-43/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-55-43/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-55-43: button.py

## Novo arquivo em backup_2025-07-03_01-55-43: controles.py

## Novo arquivo em backup_2025-07-03_01-55-43: menu.py

## Novo arquivo em backup_2025-07-03_01-55-43: score_manager.py

### Comparando com backup: backup_2025-07-03_01-56-07

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-56-07/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-56-07/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-56-07/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-56-07: button.py

## Novo arquivo em backup_2025-07-03_01-56-07: controles.py

## Novo arquivo em backup_2025-07-03_01-56-07: menu.py

## Novo arquivo em backup_2025-07-03_01-56-07: score_manager.py

### Comparando com backup: backup_2025-07-03_01-58-19

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-58-19/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-58-19/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-58-19/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-58-19: button.py

## Novo arquivo em backup_2025-07-03_01-58-19: controles.py

## Novo arquivo em backup_2025-07-03_01-58-19: menu.py

## Novo arquivo em backup_2025-07-03_01-58-19: score_manager.py

### Comparando com backup: backup_2025-07-03_01-58-39

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_01-58-39/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_01-58-39/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_01-58-39/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_01-58-39: button.py

## Novo arquivo em backup_2025-07-03_01-58-39: controles.py

## Novo arquivo em backup_2025-07-03_01-58-39: menu.py

## Novo arquivo em backup_2025-07-03_01-58-39: score_manager.py

### Comparando com backup: backup_2025-07-03_02-00-01

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_02-00-01/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_02-00-01/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_02-00-01/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_02-00-01: button.py

## Novo arquivo em backup_2025-07-03_02-00-01: controles.py

## Novo arquivo em backup_2025-07-03_02-00-01: menu.py

## Novo arquivo em backup_2025-07-03_02-00-01: score_manager.py

### Comparando com backup: backup_2025-07-03_02-01-32

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_02-01-32/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_02-01-32/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_02-01-32/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_02-01-32: button.py

## Novo arquivo em backup_2025-07-03_02-01-32: controles.py

## Novo arquivo em backup_2025-07-03_02-01-32: menu.py

## Novo arquivo em backup_2025-07-03_02-01-32: score_manager.py

### Comparando com backup: backup_2025-07-03_02-02-36

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_02-02-36/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_02-02-36/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_02-02-36/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_02-02-36: button.py

## Novo arquivo em backup_2025-07-03_02-02-36: controles.py

## Novo arquivo em backup_2025-07-03_02-02-36: menu.py

## Novo arquivo em backup_2025-07-03_02-02-36: score_manager.py

### Comparando com backup: backup_2025-07-03_02-04-56

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_02-04-56/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_02-04-56/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_02-04-56/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_02-04-56: button.py

## Novo arquivo em backup_2025-07-03_02-04-56: controles.py

## Novo arquivo em backup_2025-07-03_02-04-56: menu.py

## Novo arquivo em backup_2025-07-03_02-04-56: score_manager.py

### Comparando com backup: backup_2025-07-03_02-05-42

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_02-05-42/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_02-05-42/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_02-05-42/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_02-05-42: button.py

## Novo arquivo em backup_2025-07-03_02-05-42: controles.py

## Novo arquivo em backup_2025-07-03_02-05-42: menu.py

## Novo arquivo em backup_2025-07-03_02-05-42: score_manager.py

### Comparando com backup: backup_2025-07-03_02-06-25

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_02-06-25/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, score_manager)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_02-06-25/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_02-06-25/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_02-06-25: button.py

## Novo arquivo em backup_2025-07-03_02-06-25: controles.py

## Novo arquivo em backup_2025-07-03_02-06-25: menu.py

## Novo arquivo em backup_2025-07-03_02-06-25: score_manager.py

### Comparando com backup: backup_2025-07-03_02-08-03

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_02-08-03/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, score_manager)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_02-08-03/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_02-08-03/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_02-08-03: button.py

## Novo arquivo em backup_2025-07-03_02-08-03: controles.py

## Novo arquivo em backup_2025-07-03_02-08-03: menu.py

## Novo arquivo em backup_2025-07-03_02-08-03: score_manager.py

### Comparando com backup: backup_2025-07-03_02-09-14

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_02-09-14/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, score_manager)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_02-09-14/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_02-09-14/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_02-09-14: button.py

## Novo arquivo em backup_2025-07-03_02-09-14: controles.py

## Novo arquivo em backup_2025-07-03_02-09-14: menu.py

## Novo arquivo em backup_2025-07-03_02-09-14: score_manager.py

### Comparando com backup: backup_2025-07-03_02-12-47

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_02-12-47/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_02-12-47/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_02-12-47/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_02-12-47: button.py

## Novo arquivo em backup_2025-07-03_02-12-47: controles.py

## Novo arquivo em backup_2025-07-03_02-12-47: menu.py

## Novo arquivo em backup_2025-07-03_02-12-47: score_manager.py

### Comparando com backup: backup_2025-07-03_02-13-03

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_02-13-03/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_02-13-03/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_02-13-03/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_02-13-03: button.py

## Novo arquivo em backup_2025-07-03_02-13-03: controles.py

## Novo arquivo em backup_2025-07-03_02-13-03: menu.py

## Novo arquivo em backup_2025-07-03_02-13-03: score_manager.py

### Comparando com backup: backup_2025-07-03_12-15-52

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_12-15-52/app.py
@@ -1,43 +1,70 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_12-15-52/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_12-15-52/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_12-15-52: button.py

## Novo arquivo em backup_2025-07-03_12-15-52: controles.py

## Novo arquivo em backup_2025-07-03_12-15-52: menu.py

## Novo arquivo em backup_2025-07-03_12-15-52: score_manager.py

### Comparando com backup: backup_2025-07-03_12-19-04

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_12-19-04/app.py
@@ -1,43 +1,70 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_12-19-04/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_12-19-04/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_12-19-04: button.py

## Novo arquivo em backup_2025-07-03_12-19-04: controles.py

## Novo arquivo em backup_2025-07-03_12-19-04: menu.py

## Novo arquivo em backup_2025-07-03_12-19-04: score_manager.py

### Comparando com backup: backup_2025-07-03_12-21-31

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_12-21-31/app.py
@@ -1,43 +1,70 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_12-21-31/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_12-21-31/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_12-21-31: button.py

## Novo arquivo em backup_2025-07-03_12-21-31: controles.py

## Novo arquivo em backup_2025-07-03_12-21-31: menu.py

## Novo arquivo em backup_2025-07-03_12-21-31: score_manager.py

### Comparando com backup: backup_2025-07-03_12-39-28

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_12-39-28/app.py
@@ -1,43 +1,70 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_12-39-28/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_12-39-28/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_12-39-28: button.py

## Novo arquivo em backup_2025-07-03_12-39-28: controles.py

## Novo arquivo em backup_2025-07-03_12-39-28: menu.py

## Novo arquivo em backup_2025-07-03_12-39-28: score_manager.py

### Comparando com backup: backup_2025-07-03_12-48-23

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_12-48-23/app.py
@@ -1,43 +1,70 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_12-48-23/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_12-48-23/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_12-48-23: button.py

## Novo arquivo em backup_2025-07-03_12-48-23: controles.py

## Novo arquivo em backup_2025-07-03_12-48-23: menu.py

## Novo arquivo em backup_2025-07-03_12-48-23: score_manager.py

### Comparando com backup: backup_2025-07-03_13-02-37

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_13-02-37/app.py
@@ -1,43 +1,83 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from config import ConfigManager, ConfigMenu as FullscreenConfigMenu  # Importa o config.py

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_manager = ConfigManager()

+    fullscreen_config_menu = FullscreenConfigMenu(screen, WIDTH, HEIGHT, config_manager)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)  # seu menu de configurações (pequeno)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            # Prioriza o menu fullscreen (configurações gerais)

+            if fullscreen_config_menu.visible and fullscreen_config_menu.handle_event(event):

+                continue

+            # Se não estiver visível, trata o menu de configurações pequeno

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        fullscreen_config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_13-02-37/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_13-02-37/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_13-02-37: button.py

## Novo arquivo em backup_2025-07-03_13-02-37: config.py

## Novo arquivo em backup_2025-07-03_13-02-37: controles.py

## Novo arquivo em backup_2025-07-03_13-02-37: menu.py

## Novo arquivo em backup_2025-07-03_13-02-37: requirements.txt

## Novo arquivo em backup_2025-07-03_13-02-37: score_manager.py

### Comparando com backup: backup_2025-07-03_13-04-26

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_13-04-26/app.py
@@ -1,43 +1,83 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from config import ConfigManager, ConfigMenu as FullscreenConfigMenu  # Importa o config.py

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_manager = ConfigManager()

+    fullscreen_config_menu = FullscreenConfigMenu(screen, WIDTH, HEIGHT, config_manager)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)  # seu menu de configurações (pequeno)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            # Prioriza o menu fullscreen (configurações gerais)

+            if fullscreen_config_menu.visible and fullscreen_config_menu.handle_event(event):

+                continue

+            # Se não estiver visível, trata o menu de configurações pequeno

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        fullscreen_config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_13-04-26/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_13-04-26/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_13-04-26: button.py

## Novo arquivo em backup_2025-07-03_13-04-26: config.py

## Novo arquivo em backup_2025-07-03_13-04-26: controles.py

## Novo arquivo em backup_2025-07-03_13-04-26: menu.py

## Novo arquivo em backup_2025-07-03_13-04-26: requirements.txt

## Novo arquivo em backup_2025-07-03_13-04-26: score_manager.py

### Comparando com backup: backup_2025-07-03_13-05-13

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_13-05-13/app.py
@@ -1,43 +1,83 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from config import ConfigManager, ConfigMenu as FullscreenConfigMenu  # Importa o config.py

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_manager = ConfigManager()

+    fullscreen_config_menu = FullscreenConfigMenu(screen, WIDTH, HEIGHT, config_manager)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)  # seu menu de configurações (pequeno)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            # Prioriza o menu fullscreen (configurações gerais)

+            if fullscreen_config_menu.visible and fullscreen_config_menu.handle_event(event):

+                continue

+            # Se não estiver visível, trata o menu de configurações pequeno

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        fullscreen_config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_13-05-13/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_13-05-13/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_13-05-13: button.py

## Novo arquivo em backup_2025-07-03_13-05-13: config.py

## Novo arquivo em backup_2025-07-03_13-05-13: controles.py

## Novo arquivo em backup_2025-07-03_13-05-13: menu.py

## Novo arquivo em backup_2025-07-03_13-05-13: requirements.txt

## Novo arquivo em backup_2025-07-03_13-05-13: score_manager.py

### Comparando com backup: backup_2025-07-03_13-06-51

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_13-06-51/app.py
@@ -1,43 +1,83 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from config import ConfigManager, ConfigMenu as FullscreenConfigMenu  # Importa o config.py

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_manager = ConfigManager()

+    fullscreen_config_menu = FullscreenConfigMenu(screen, WIDTH, HEIGHT, config_manager)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)  # seu menu de configurações (pequeno)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            # Prioriza o menu fullscreen (configurações gerais)

+            if fullscreen_config_menu.visible and fullscreen_config_menu.handle_event(event):

+                continue

+            # Se não estiver visível, trata o menu de configurações pequeno

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+

+        fullscreen_config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_13-06-51/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_13-06-51/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_13-06-51: button.py

## Novo arquivo em backup_2025-07-03_13-06-51: config.py

## Novo arquivo em backup_2025-07-03_13-06-51: controles.py

## Novo arquivo em backup_2025-07-03_13-06-51: menu.py

## Novo arquivo em backup_2025-07-03_13-06-51: requirements.txt

## Novo arquivo em backup_2025-07-03_13-06-51: score_manager.py

### Comparando com backup: backup_2025-07-03_13-08-12

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_13-08-12/app.py
@@ -1,43 +1,85 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu  # Menu principal com controles embutidos

+from config import ConfigManager, ConfigMenu as FullscreenConfigMenu  # Menu fullscreen (config.py)

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_manager = ConfigManager()

+    fullscreen_config_menu = FullscreenConfigMenu(screen, WIDTH, HEIGHT, config_manager)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)  # menu pequeno, inclui controles

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            # Se menu fullscreen estiver aberto, ele consome eventos

+            if fullscreen_config_menu.visible and fullscreen_config_menu.handle_event(event):

+                continue

+            # Se não, o menu pequeno consome eventos

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+        config_menu.controls_menu.draw()

+

+        fullscreen_config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_13-08-12/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_13-08-12/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_13-08-12: button.py

## Novo arquivo em backup_2025-07-03_13-08-12: config.py

## Novo arquivo em backup_2025-07-03_13-08-12: controles.py

## Novo arquivo em backup_2025-07-03_13-08-12: menu.py

## Novo arquivo em backup_2025-07-03_13-08-12: requirements.txt

## Novo arquivo em backup_2025-07-03_13-08-12: score_manager.py

### Comparando com backup: backup_2025-07-03_13-09-35

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_13-09-35/app.py
@@ -1,43 +1,85 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu  # Menu principal com controles embutidos

+from config import ConfigManager, ConfigMenu as FullscreenConfigMenu  # Menu fullscreen (config.py)

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_manager = ConfigManager()

+    fullscreen_config_menu = FullscreenConfigMenu(screen, WIDTH, HEIGHT, config_manager)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)  # menu pequeno, inclui controles

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            # Se menu fullscreen estiver aberto, ele consome eventos

+            if fullscreen_config_menu.visible and fullscreen_config_menu.handle_event(event):

+                continue

+            # Se não, o menu pequeno consome eventos

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+        config_menu.controls_menu.draw()

+

+        fullscreen_config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_13-09-35/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_13-09-35/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_13-09-35: button.py

## Novo arquivo em backup_2025-07-03_13-09-35: config.py

## Novo arquivo em backup_2025-07-03_13-09-35: controles.py

## Novo arquivo em backup_2025-07-03_13-09-35: menu.py

## Novo arquivo em backup_2025-07-03_13-09-35: requirements.txt

## Novo arquivo em backup_2025-07-03_13-09-35: score_manager.py

### Comparando com backup: backup_2025-07-03_13-10-06

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_13-10-06/app.py
@@ -1,43 +1,75 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+        config_menu.controls_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_13-10-06/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_13-10-06/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_13-10-06: button.py

## Novo arquivo em backup_2025-07-03_13-10-06: config.py

## Novo arquivo em backup_2025-07-03_13-10-06: controles.py

## Novo arquivo em backup_2025-07-03_13-10-06: menu.py

## Novo arquivo em backup_2025-07-03_13-10-06: requirements.txt

## Novo arquivo em backup_2025-07-03_13-10-06: score_manager.py

### Comparando com backup: backup_2025-07-03_13-12-16

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_13-12-16/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu  # menu principal (ícone + opções + controle do controles)

+# controles.py contém ControlsMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        for event in pygame.event.get():

+            # Prioridade para menus (controle de eventos)

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        # Desenha o ícone do menu, o menu pequeno e o menu controles (se visível)

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+        config_menu.controls_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_13-12-16/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_13-12-16/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_13-12-16: button.py

## Novo arquivo em backup_2025-07-03_13-12-16: config.py

## Novo arquivo em backup_2025-07-03_13-12-16: controles.py

## Novo arquivo em backup_2025-07-03_13-12-16: menu.py

## Novo arquivo em backup_2025-07-03_13-12-16: requirements.txt

## Novo arquivo em backup_2025-07-03_13-12-16: score_manager.py

### Comparando com backup: backup_2025-07-03_13-14-09

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_13-14-09/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu  # menu principal (ícone + opções + controle do controles)

+# controles.py contém ControlsMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        for event in pygame.event.get():

+            # Prioridade para menus (controle de eventos)

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        # Desenha o ícone do menu, o menu pequeno e o menu controles (se visível)

+        config_menu.draw_icon()

+        config_menu.draw_menu()

+        config_menu.controls_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_13-14-09/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_13-14-09/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_13-14-09: button.py

## Novo arquivo em backup_2025-07-03_13-14-09: config.py

## Novo arquivo em backup_2025-07-03_13-14-09: controles.py

## Novo arquivo em backup_2025-07-03_13-14-09: menu.py

## Novo arquivo em backup_2025-07-03_13-14-09: requirements.txt

## Novo arquivo em backup_2025-07-03_13-14-09: score_manager.py

### Comparando com backup: backup_2025-07-03_15-27-55

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_15-27-55/app.py
@@ -1,43 +1,69 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_15-27-55/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_15-27-55/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_15-27-55: button.py

## Novo arquivo em backup_2025-07-03_15-27-55: config.py

## Novo arquivo em backup_2025-07-03_15-27-55: controles.py

## Novo arquivo em backup_2025-07-03_15-27-55: menu.py

## Novo arquivo em backup_2025-07-03_15-27-55: requirements.txt

## Novo arquivo em backup_2025-07-03_15-27-55: score_manager.py

### Comparando com backup: backup_2025-07-03_15-31-14

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_15-31-14/app.py
@@ -1,43 +1,69 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_15-31-14/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_15-31-14/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_15-31-14: button.py

## Novo arquivo em backup_2025-07-03_15-31-14: config.py

## Novo arquivo em backup_2025-07-03_15-31-14: controles.py

## Novo arquivo em backup_2025-07-03_15-31-14: menu.py

## Novo arquivo em backup_2025-07-03_15-31-14: requirements.txt

## Novo arquivo em backup_2025-07-03_15-31-14: score_manager.py

### Comparando com backup: backup_2025-07-03_15-34-34

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_15-34-34/app.py
@@ -1,43 +1,69 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_15-34-34/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_15-34-34/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_15-34-34: button.py

## Novo arquivo em backup_2025-07-03_15-34-34: config.py

## Novo arquivo em backup_2025-07-03_15-34-34: controles.py

## Novo arquivo em backup_2025-07-03_15-34-34: menu.py

## Novo arquivo em backup_2025-07-03_15-34-34: requirements.txt

## Novo arquivo em backup_2025-07-03_15-34-34: score_manager.py

### Comparando com backup: backup_2025-07-03_15-37-03

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_15-37-03/app.py
@@ -1,43 +1,69 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_15-37-03/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_15-37-03/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_15-37-03: button.py

## Novo arquivo em backup_2025-07-03_15-37-03: config.py

## Novo arquivo em backup_2025-07-03_15-37-03: controles.py

## Novo arquivo em backup_2025-07-03_15-37-03: menu.py

## Novo arquivo em backup_2025-07-03_15-37-03: requirements.txt

## Novo arquivo em backup_2025-07-03_15-37-03: score_manager.py

### Comparando com backup: backup_2025-07-03_15-38-27

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_15-38-27/app.py
@@ -1,43 +1,69 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_15-38-27/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_15-38-27/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_15-38-27: button.py

## Novo arquivo em backup_2025-07-03_15-38-27: config.py

## Novo arquivo em backup_2025-07-03_15-38-27: controles.py

## Novo arquivo em backup_2025-07-03_15-38-27: menu.py

## Novo arquivo em backup_2025-07-03_15-38-27: requirements.txt

## Novo arquivo em backup_2025-07-03_15-38-27: score_manager.py

### Comparando com backup: backup_2025-07-03_15-41-19

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_15-41-19/app.py
@@ -1,43 +1,69 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score = score_manager.load_score()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_score(score)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_15-41-19/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_15-41-19/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_15-41-19: button.py

## Novo arquivo em backup_2025-07-03_15-41-19: config.py

## Novo arquivo em backup_2025-07-03_15-41-19: controles.py

## Novo arquivo em backup_2025-07-03_15-41-19: menu.py

## Novo arquivo em backup_2025-07-03_15-41-19: requirements.txt

## Novo arquivo em backup_2025-07-03_15-41-19: score_manager.py

### Comparando com backup: backup_2025-07-03_15-44-39

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_15-44-39/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_15-44-39/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_15-44-39/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_15-44-39: button.py

## Novo arquivo em backup_2025-07-03_15-44-39: config.py

## Novo arquivo em backup_2025-07-03_15-44-39: controles.py

## Novo arquivo em backup_2025-07-03_15-44-39: menu.py

## Novo arquivo em backup_2025-07-03_15-44-39: requirements.txt

## Novo arquivo em backup_2025-07-03_15-44-39: score_manager.py

### Comparando com backup: backup_2025-07-03_15-45-40

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_15-45-40/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_15-45-40/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_15-45-40/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_15-45-40: button.py

## Novo arquivo em backup_2025-07-03_15-45-40: config.py

## Novo arquivo em backup_2025-07-03_15-45-40: controles.py

## Novo arquivo em backup_2025-07-03_15-45-40: menu.py

## Novo arquivo em backup_2025-07-03_15-45-40: requirements.txt

## Novo arquivo em backup_2025-07-03_15-45-40: score_manager.py

### Comparando com backup: backup_2025-07-03_15-46-56

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_15-46-56/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_15-46-56/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_15-46-56/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_15-46-56: button.py

## Novo arquivo em backup_2025-07-03_15-46-56: config.py

## Novo arquivo em backup_2025-07-03_15-46-56: controles.py

## Novo arquivo em backup_2025-07-03_15-46-56: menu.py

## Novo arquivo em backup_2025-07-03_15-46-56: requirements.txt

## Novo arquivo em backup_2025-07-03_15-46-56: score_manager.py

### Comparando com backup: backup_2025-07-03_15-48-32

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_15-48-32/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_15-48-32/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_15-48-32/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_15-48-32: button.py

## Novo arquivo em backup_2025-07-03_15-48-32: config.py

## Novo arquivo em backup_2025-07-03_15-48-32: controles.py

## Novo arquivo em backup_2025-07-03_15-48-32: menu.py

## Novo arquivo em backup_2025-07-03_15-48-32: requirements.txt

## Novo arquivo em backup_2025-07-03_15-48-32: score_manager.py

### Comparando com backup: backup_2025-07-03_15-49-27

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_15-49-27/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_15-49-27/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_15-49-27/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_15-49-27: button.py

## Novo arquivo em backup_2025-07-03_15-49-27: config.py

## Novo arquivo em backup_2025-07-03_15-49-27: controles.py

## Novo arquivo em backup_2025-07-03_15-49-27: menu.py

## Novo arquivo em backup_2025-07-03_15-49-27: requirements.txt

## Novo arquivo em backup_2025-07-03_15-49-27: score_manager.py

### Comparando com backup: backup_2025-07-03_15-52-37

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_15-52-37/app.py
@@ -1,43 +1,89 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu1 import MainMenu

+from menu2 import SubMenus

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    options = ["Configurações", "Volume: [•••••]", "Tema: Claro", "Controles"]

+

+    submenus = SubMenus(screen, WIDTH, HEIGHT)

+    submenus.controls_menu.visible = controls_visible

+

+    def on_option_select(selected):

+        if selected == "Controles":

+            submenus.toggle_menu("Controles")

+        elif selected == "Configurações":

+            submenus.toggle_menu("Configurações")

+        # Pode adicionar lógica para Volume, Tema etc se quiser

+

+    main_menu = MainMenu(screen, WIDTH, HEIGHT, options, on_option_select)

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if submenus.handle_event(event):

+                continue  # evento consumido pelos submenus

+            if main_menu.handle_event(event):

+                continue  # evento consumido pelo menu principal

+

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        main_menu.draw()

+        submenus.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, submenus.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_15-52-37/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_15-52-37/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_15-52-37: button.py

## Novo arquivo em backup_2025-07-03_15-52-37: config.py

## Novo arquivo em backup_2025-07-03_15-52-37: controles.py

## Novo arquivo em backup_2025-07-03_15-52-37: menu1.py

## Novo arquivo em backup_2025-07-03_15-52-37: menu2.py

## Novo arquivo em backup_2025-07-03_15-52-37: requirements.txt

## Novo arquivo em backup_2025-07-03_15-52-37: score_manager.py

### Comparando com backup: backup_2025-07-03_15-56-30

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-03_15-56-30/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-03_15-56-30/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-03_15-56-30/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-03_15-56-30: button.py

## Novo arquivo em backup_2025-07-03_15-56-30: config.py

## Novo arquivo em backup_2025-07-03_15-56-30: controles.py

## Novo arquivo em backup_2025-07-03_15-56-30: menu.py

## Novo arquivo em backup_2025-07-03_15-56-30: requirements.txt

## Novo arquivo em backup_2025-07-03_15-56-30: score_manager.py

### Comparando com backup: backup_2025-07-04_12-25-25

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_12-25-25/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_12-25-25/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_12-25-25/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_12-25-25: button.py

## Novo arquivo em backup_2025-07-04_12-25-25: config.py

## Novo arquivo em backup_2025-07-04_12-25-25: controles.py

## Novo arquivo em backup_2025-07-04_12-25-25: menu.py

## Novo arquivo em backup_2025-07-04_12-25-25: requirements.txt

## Novo arquivo em backup_2025-07-04_12-25-25: score_manager.py

### Comparando com backup: backup_2025-07-04_12-36-14

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_12-36-14/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_12-36-14/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_12-36-14/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_12-36-14: button.py

## Novo arquivo em backup_2025-07-04_12-36-14: config.py

## Novo arquivo em backup_2025-07-04_12-36-14: controles.py

## Novo arquivo em backup_2025-07-04_12-36-14: menu.py

## Novo arquivo em backup_2025-07-04_12-36-14: requirements.txt

## Novo arquivo em backup_2025-07-04_12-36-14: score_manager.py

### Comparando com backup: backup_2025-07-04_12-38-53

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_12-38-53/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_12-38-53/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_12-38-53/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_12-38-53: button.py

## Novo arquivo em backup_2025-07-04_12-38-53: config.py

## Novo arquivo em backup_2025-07-04_12-38-53: controles.py

## Novo arquivo em backup_2025-07-04_12-38-53: menu.py

## Novo arquivo em backup_2025-07-04_12-38-53: requirements.txt

## Novo arquivo em backup_2025-07-04_12-38-53: score_manager.py

### Comparando com backup: backup_2025-07-04_12-41-53

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_12-41-53/app.py
@@ -1,43 +1,74 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    button.click()

+                    score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_12-41-53/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_12-41-53/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_12-41-53: button.py

## Novo arquivo em backup_2025-07-04_12-41-53: config.py

## Novo arquivo em backup_2025-07-04_12-41-53: controles.py

## Novo arquivo em backup_2025-07-04_12-41-53: menu.py

## Novo arquivo em backup_2025-07-04_12-41-53: requirements.txt

## Novo arquivo em backup_2025-07-04_12-41-53: score_manager.py

### Comparando com backup: backup_2025-07-04_12-44-31

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_12-44-31/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_12-44-31/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_12-44-31/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_12-44-31: button.py

## Novo arquivo em backup_2025-07-04_12-44-31: config.py

## Novo arquivo em backup_2025-07-04_12-44-31: controles.py

## Novo arquivo em backup_2025-07-04_12-44-31: menu.py

## Novo arquivo em backup_2025-07-04_12-44-31: requirements.txt

## Novo arquivo em backup_2025-07-04_12-44-31: score_manager.py

### Comparando com backup: backup_2025-07-04_12-47-56

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_12-47-56/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_12-47-56/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_12-47-56/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_12-47-56: button.py

## Novo arquivo em backup_2025-07-04_12-47-56: config.py

## Novo arquivo em backup_2025-07-04_12-47-56: controles.py

## Novo arquivo em backup_2025-07-04_12-47-56: menu.py

## Novo arquivo em backup_2025-07-04_12-47-56: requirements.txt

## Novo arquivo em backup_2025-07-04_12-47-56: score_manager.py

### Comparando com backup: backup_2025-07-04_12-51-02

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_12-51-02/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_12-51-02/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_12-51-02/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_12-51-02: button.py

## Novo arquivo em backup_2025-07-04_12-51-02: config.py

## Novo arquivo em backup_2025-07-04_12-51-02: controles.py

## Novo arquivo em backup_2025-07-04_12-51-02: menu.py

## Novo arquivo em backup_2025-07-04_12-51-02: requirements.txt

## Novo arquivo em backup_2025-07-04_12-51-02: score_manager.py

### Comparando com backup: backup_2025-07-04_12-53-14

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_12-53-14/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_12-53-14/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_12-53-14/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_12-53-14: button.py

## Novo arquivo em backup_2025-07-04_12-53-14: config.py

## Novo arquivo em backup_2025-07-04_12-53-14: controles.py

## Novo arquivo em backup_2025-07-04_12-53-14: menu.py

## Novo arquivo em backup_2025-07-04_12-53-14: requirements.txt

## Novo arquivo em backup_2025-07-04_12-53-14: score_manager.py

### Comparando com backup: backup_2025-07-04_12-55-20

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_12-55-20/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_12-55-20/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_12-55-20/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_12-55-20: button.py

## Novo arquivo em backup_2025-07-04_12-55-20: config.py

## Novo arquivo em backup_2025-07-04_12-55-20: controles.py

## Novo arquivo em backup_2025-07-04_12-55-20: menu.py

## Novo arquivo em backup_2025-07-04_12-55-20: requirements.txt

## Novo arquivo em backup_2025-07-04_12-55-20: score_manager.py

### Comparando com backup: backup_2025-07-04_12-57-14

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_12-57-14/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_12-57-14/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_12-57-14/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_12-57-14: button.py

## Novo arquivo em backup_2025-07-04_12-57-14: config.py

## Novo arquivo em backup_2025-07-04_12-57-14: controles.py

## Novo arquivo em backup_2025-07-04_12-57-14: menu.py

## Novo arquivo em backup_2025-07-04_12-57-14: requirements.txt

## Novo arquivo em backup_2025-07-04_12-57-14: score_manager.py

### Comparando com backup: backup_2025-07-04_12-59-48

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_12-59-48/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_12-59-48/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_12-59-48/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_12-59-48: button.py

## Novo arquivo em backup_2025-07-04_12-59-48: config.py

## Novo arquivo em backup_2025-07-04_12-59-48: controles.py

## Novo arquivo em backup_2025-07-04_12-59-48: menu.py

## Novo arquivo em backup_2025-07-04_12-59-48: requirements.txt

## Novo arquivo em backup_2025-07-04_12-59-48: score_manager.py

### Comparando com backup: backup_2025-07-04_13-00-36

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_13-00-36/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_13-00-36/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_13-00-36/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_13-00-36: button.py

## Novo arquivo em backup_2025-07-04_13-00-36: config.py

## Novo arquivo em backup_2025-07-04_13-00-36: controles.py

## Novo arquivo em backup_2025-07-04_13-00-36: menu.py

## Novo arquivo em backup_2025-07-04_13-00-36: requirements.txt

## Novo arquivo em backup_2025-07-04_13-00-36: score_manager.py

### Comparando com backup: backup_2025-07-04_13-01-55

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_13-01-55/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_13-01-55/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_13-01-55/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_13-01-55: button.py

## Novo arquivo em backup_2025-07-04_13-01-55: config.py

## Novo arquivo em backup_2025-07-04_13-01-55: controles.py

## Novo arquivo em backup_2025-07-04_13-01-55: menu.py

## Novo arquivo em backup_2025-07-04_13-01-55: requirements.txt

## Novo arquivo em backup_2025-07-04_13-01-55: score_manager.py

### Comparando com backup: backup_2025-07-04_13-03-05

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_13-03-05/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_13-03-05/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_13-03-05/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_13-03-05: button.py

## Novo arquivo em backup_2025-07-04_13-03-05: config.py

## Novo arquivo em backup_2025-07-04_13-03-05: controles.py

## Novo arquivo em backup_2025-07-04_13-03-05: menu.py

## Novo arquivo em backup_2025-07-04_13-03-05: requirements.txt

## Novo arquivo em backup_2025-07-04_13-03-05: score_manager.py

### Comparando com backup: backup_2025-07-04_13-03-59

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_13-03-59/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_13-03-59/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_13-03-59/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_13-03-59: button.py

## Novo arquivo em backup_2025-07-04_13-03-59: config.py

## Novo arquivo em backup_2025-07-04_13-03-59: controles.py

## Novo arquivo em backup_2025-07-04_13-03-59: menu.py

## Novo arquivo em backup_2025-07-04_13-03-59: requirements.txt

## Novo arquivo em backup_2025-07-04_13-03-59: score_manager.py

### Comparando com backup: backup_2025-07-04_13-04-14

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_13-04-14/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_13-04-14/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_13-04-14/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_13-04-14: button.py

## Novo arquivo em backup_2025-07-04_13-04-14: config.py

## Novo arquivo em backup_2025-07-04_13-04-14: controles.py

## Novo arquivo em backup_2025-07-04_13-04-14: menu.py

## Novo arquivo em backup_2025-07-04_13-04-14: requirements.txt

## Novo arquivo em backup_2025-07-04_13-04-14: score_manager.py

### Comparando com backup: backup_2025-07-04_13-06-32

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_13-06-32/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_13-06-32/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_13-06-32/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_13-06-32: button.py

## Novo arquivo em backup_2025-07-04_13-06-32: config.py

## Novo arquivo em backup_2025-07-04_13-06-32: controles.py

## Novo arquivo em backup_2025-07-04_13-06-32: menu.py

## Novo arquivo em backup_2025-07-04_13-06-32: requirements.txt

## Novo arquivo em backup_2025-07-04_13-06-32: score_manager.py

### Comparando com backup: backup_2025-07-04_13-06-59

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_13-06-59/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_13-06-59/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_13-06-59/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_13-06-59: button.py

## Novo arquivo em backup_2025-07-04_13-06-59: config.py

## Novo arquivo em backup_2025-07-04_13-06-59: controles.py

## Novo arquivo em backup_2025-07-04_13-06-59: menu.py

## Novo arquivo em backup_2025-07-04_13-06-59: requirements.txt

## Novo arquivo em backup_2025-07-04_13-06-59: score_manager.py

### Comparando com backup: backup_2025-07-04_13-07-14

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_13-07-14/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_13-07-14/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_13-07-14/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_13-07-14: button.py

## Novo arquivo em backup_2025-07-04_13-07-14: config.py

## Novo arquivo em backup_2025-07-04_13-07-14: controles.py

## Novo arquivo em backup_2025-07-04_13-07-14: menu.py

## Novo arquivo em backup_2025-07-04_13-07-14: requirements.txt

## Novo arquivo em backup_2025-07-04_13-07-14: score_manager.py

### Comparando com backup: backup_2025-07-04_13-08-28

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_13-08-28/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_13-08-28/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_13-08-28/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_13-08-28: button.py

## Novo arquivo em backup_2025-07-04_13-08-28: config.py

## Novo arquivo em backup_2025-07-04_13-08-28: controles.py

## Novo arquivo em backup_2025-07-04_13-08-28: menu.py

## Novo arquivo em backup_2025-07-04_13-08-28: requirements.txt

## Novo arquivo em backup_2025-07-04_13-08-28: score_manager.py

### Comparando com backup: backup_2025-07-04_13-08-46

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_13-08-46/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_13-08-46/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_13-08-46/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_13-08-46: button.py

## Novo arquivo em backup_2025-07-04_13-08-46: config.py

## Novo arquivo em backup_2025-07-04_13-08-46: controles.py

## Novo arquivo em backup_2025-07-04_13-08-46: menu.py

## Novo arquivo em backup_2025-07-04_13-08-46: requirements.txt

## Novo arquivo em backup_2025-07-04_13-08-46: score_manager.py

### Comparando com backup: backup_2025-07-04_13-09-16

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_13-09-16/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_13-09-16/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_13-09-16/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_13-09-16: button.py

## Novo arquivo em backup_2025-07-04_13-09-16: config.py

## Novo arquivo em backup_2025-07-04_13-09-16: controles.py

## Novo arquivo em backup_2025-07-04_13-09-16: menu.py

## Novo arquivo em backup_2025-07-04_13-09-16: requirements.txt

## Novo arquivo em backup_2025-07-04_13-09-16: score_manager.py

### Comparando com backup: backup_2025-07-04_13-10-29

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_13-10-29/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_13-10-29/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_13-10-29/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_13-10-29: button.py

## Novo arquivo em backup_2025-07-04_13-10-29: config.py

## Novo arquivo em backup_2025-07-04_13-10-29: controles.py

## Novo arquivo em backup_2025-07-04_13-10-29: menu.py

## Novo arquivo em backup_2025-07-04_13-10-29: requirements.txt

## Novo arquivo em backup_2025-07-04_13-10-29: score_manager.py

### Comparando com backup: backup_2025-07-04_13-16-53

## Novo arquivo em backup_2025-07-04_13-16-53: MarkupSafe-3.0.2.dist-info\INSTALLER

## Novo arquivo em backup_2025-07-04_13-16-53: MarkupSafe-3.0.2.dist-info\LICENSE.txt

## Novo arquivo em backup_2025-07-04_13-16-53: MarkupSafe-3.0.2.dist-info\METADATA

## Novo arquivo em backup_2025-07-04_13-16-53: MarkupSafe-3.0.2.dist-info\RECORD

## Novo arquivo em backup_2025-07-04_13-16-53: MarkupSafe-3.0.2.dist-info\WHEEL

## Novo arquivo em backup_2025-07-04_13-16-53: MarkupSafe-3.0.2.dist-info\top_level.txt

## Novo arquivo em backup_2025-07-04_13-16-53: PIL\_avif.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: PIL\_imaging.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: PIL\_imagingcms.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: PIL\_imagingmath.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: PIL\_imagingtk.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: PIL\_webp.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: Pythonwin\mfc140u.dll

## Novo arquivo em backup_2025-07-04_13-16-53: Pythonwin\win32ui.pyd

## Arquivo removido em backup_2025-07-04_13-16-53: README.md

## Novo arquivo em backup_2025-07-04_13-16-53: SDL2.dll

## Novo arquivo em backup_2025-07-04_13-16-53: SDL2_image.dll

## Novo arquivo em backup_2025-07-04_13-16-53: SDL2_mixer.dll

## Novo arquivo em backup_2025-07-04_13-16-53: SDL2_ttf.dll

## Novo arquivo em backup_2025-07-04_13-16-53: VCRUNTIME140.dll

## Novo arquivo em backup_2025-07-04_13-16-53: VCRUNTIME140_1.dll

## Novo arquivo em backup_2025-07-04_13-16-53: _asyncio.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: _bz2.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: _ctypes.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: _decimal.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: _elementtree.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: _hashlib.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: _lzma.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: _multiprocessing.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: _overlapped.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: _queue.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: _socket.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: _ssl.pyd

## Arquivo removido em backup_2025-07-04_13-16-53: app.py

## Arquivo removido em backup_2025-07-04_13-16-53: background.py

## Arquivo removido em backup_2025-07-04_13-16-53: backup.py

## Novo arquivo em backup_2025-07-04_13-16-53: base_library.zip

## Novo arquivo em backup_2025-07-04_13-16-53: certifi\cacert.pem

## Novo arquivo em backup_2025-07-04_13-16-53: certifi\py.typed

## Novo arquivo em backup_2025-07-04_13-16-53: charset_normalizer\md.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: charset_normalizer\md__mypyc.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: freetype.dll

## Novo arquivo em backup_2025-07-04_13-16-53: libcrypto-3.dll

## Novo arquivo em backup_2025-07-04_13-16-53: libffi-8.dll

## Novo arquivo em backup_2025-07-04_13-16-53: libjpeg-9.dll

## Novo arquivo em backup_2025-07-04_13-16-53: libmodplug-1.dll

## Novo arquivo em backup_2025-07-04_13-16-53: libogg-0.dll

## Novo arquivo em backup_2025-07-04_13-16-53: libopus-0.dll

## Novo arquivo em backup_2025-07-04_13-16-53: libopusfile-0.dll

## Novo arquivo em backup_2025-07-04_13-16-53: libpng16-16.dll

## Novo arquivo em backup_2025-07-04_13-16-53: libssl-3.dll

## Novo arquivo em backup_2025-07-04_13-16-53: libtiff-5.dll

## Novo arquivo em backup_2025-07-04_13-16-53: libwebp-7.dll

## Novo arquivo em backup_2025-07-04_13-16-53: markupsafe\_speedups.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: portmidi.dll

## Novo arquivo em backup_2025-07-04_13-16-53: pyexpat.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\SDL2.dll

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\SDL2_image.dll

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\SDL2_mixer.dll

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\SDL2_ttf.dll

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\_freetype.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\base.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\bufferproxy.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\color.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\constants.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\display.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\draw.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\event.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\font.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\freesansbold.ttf

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\freetype.dll

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\image.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\imageext.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\joystick.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\key.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\libjpeg-9.dll

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\libogg-0.dll

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\libopus-0.dll

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\libpng16-16.dll

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\mask.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\math.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\mixer.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\mixer_music.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\mouse.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\pixelarray.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\pixelcopy.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\pygame_icon.bmp

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\rect.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\rwobject.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\scrap.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\surface.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\surflock.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\time.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\transform.cp311-win_amd64.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: pygame\zlib1.dll

## Novo arquivo em backup_2025-07-04_13-16-53: python311.dll

## Novo arquivo em backup_2025-07-04_13-16-53: pywin32_system32\pythoncom311.dll

## Novo arquivo em backup_2025-07-04_13-16-53: pywin32_system32\pywintypes311.dll

## Novo arquivo em backup_2025-07-04_13-16-53: select.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: unicodedata.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: win32\_win32sysloader.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: win32\win32api.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: win32\win32event.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: win32\win32trace.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: win32com\shell\shell.pyd

## Novo arquivo em backup_2025-07-04_13-16-53: zlib1.dll

### Comparando com backup: backup_2025-07-04_13-59-26

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_13-59-26/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_13-59-26/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_13-59-26/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_13-59-26: button.py

## Novo arquivo em backup_2025-07-04_13-59-26: config.py

## Novo arquivo em backup_2025-07-04_13-59-26: controles.py

## Novo arquivo em backup_2025-07-04_13-59-26: menu.py

## Novo arquivo em backup_2025-07-04_13-59-26: score_manager.py

### Comparando com backup: backup_2025-07-04_14-25-16

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_14-25-16/app.py
@@ -1,43 +1,76 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

+    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\unitypy\backups"

 

-    # Faz backup no início do app

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                # Verifica se o clique está permitido conforme config

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_14-25-16/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_14-25-16/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_14-25-16: button.py

## Novo arquivo em backup_2025-07-04_14-25-16: config.py

## Novo arquivo em backup_2025-07-04_14-25-16: controles.py

## Novo arquivo em backup_2025-07-04_14-25-16: menu.py

## Novo arquivo em backup_2025-07-04_14-25-16: score_manager.py

## Novo arquivo em backup_2025-07-04_14-25-16: server.py

### Comparando com backup: backup_2025-07-04_14-34-52

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_14-34-52/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_14-34-52/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_14-34-52/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_14-34-52: button.py

## Novo arquivo em backup_2025-07-04_14-34-52: config.py

## Novo arquivo em backup_2025-07-04_14-34-52: controles.py

## Novo arquivo em backup_2025-07-04_14-34-52: menu.py

## Novo arquivo em backup_2025-07-04_14-34-52: score_manager.py

### Comparando com backup: backup_2025-07-04_14-35-55

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_14-35-55/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_14-35-55/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_14-35-55/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_14-35-55: button.py

## Novo arquivo em backup_2025-07-04_14-35-55: config.py

## Novo arquivo em backup_2025-07-04_14-35-55: controles.py

## Novo arquivo em backup_2025-07-04_14-35-55: menu.py

## Novo arquivo em backup_2025-07-04_14-35-55: score_manager.py

### Comparando com backup: backup_2025-07-04_14-37-05

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_14-37-05/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_14-37-05/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_14-37-05/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_14-37-05: button.py

## Novo arquivo em backup_2025-07-04_14-37-05: config.py

## Novo arquivo em backup_2025-07-04_14-37-05: controles.py

## Novo arquivo em backup_2025-07-04_14-37-05: menu.py

## Novo arquivo em backup_2025-07-04_14-37-05: score_manager.py

### Comparando com backup: backup_2025-07-04_14-38-24

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_14-38-24/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_14-38-24/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_14-38-24/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_14-38-24: button.py

## Novo arquivo em backup_2025-07-04_14-38-24: config.py

## Novo arquivo em backup_2025-07-04_14-38-24: controles.py

## Novo arquivo em backup_2025-07-04_14-38-24: menu.py

## Novo arquivo em backup_2025-07-04_14-38-24: score_manager.py

### Comparando com backup: backup_2025-07-04_14-40-08

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_14-40-08/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_14-40-08/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_14-40-08/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_14-40-08: button.py

## Novo arquivo em backup_2025-07-04_14-40-08: config.py

## Novo arquivo em backup_2025-07-04_14-40-08: controles.py

## Novo arquivo em backup_2025-07-04_14-40-08: menu.py

## Novo arquivo em backup_2025-07-04_14-40-08: score_manager.py

### Comparando com backup: backup_2025-07-04_14-40-27

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_14-40-27/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_14-40-27/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_14-40-27/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_14-40-27: button.py

## Novo arquivo em backup_2025-07-04_14-40-27: config.py

## Novo arquivo em backup_2025-07-04_14-40-27: controles.py

## Novo arquivo em backup_2025-07-04_14-40-27: menu.py

## Novo arquivo em backup_2025-07-04_14-40-27: score_manager.py

### Comparando com backup: backup_2025-07-04_14-41-27

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_14-41-27/app.py
@@ -1,43 +1,73 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_14-41-27/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_14-41-27/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_14-41-27: button.py

## Novo arquivo em backup_2025-07-04_14-41-27: config.py

## Novo arquivo em backup_2025-07-04_14-41-27: controles.py

## Novo arquivo em backup_2025-07-04_14-41-27: menu.py

## Novo arquivo em backup_2025-07-04_14-41-27: score_manager.py

### Comparando com backup: backup_2025-07-04_15-13-00

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_15-13-00/app.py
@@ -1,43 +1,93 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Criar a tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula processo de carregamento com atualizações na tela de loading

+    steps = [

+        ("Preparando backup...", 20),

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua por código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    # Passa callback para menu para atualizar loading ao baixar ícone

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_15-13-00/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_15-13-00/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_15-13-00: button.py

## Novo arquivo em backup_2025-07-04_15-13-00: config.py

## Novo arquivo em backup_2025-07-04_15-13-00: controles.py

## Novo arquivo em backup_2025-07-04_15-13-00: loading.py

## Novo arquivo em backup_2025-07-04_15-13-00: menu.py

## Novo arquivo em backup_2025-07-04_15-13-00: score_manager.py

### Comparando com backup: backup_2025-07-04_15-13-22

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_15-13-22/app.py
@@ -1,43 +1,93 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Criar a tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula processo de carregamento com atualizações na tela de loading

+    steps = [

+        ("Preparando backup...", 20),

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua por código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    # Passa callback para menu para atualizar loading ao baixar ícone

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_15-13-22/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_15-13-22/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_15-13-22: button.py

## Novo arquivo em backup_2025-07-04_15-13-22: config.py

## Novo arquivo em backup_2025-07-04_15-13-22: controles.py

## Novo arquivo em backup_2025-07-04_15-13-22: loading.py

## Novo arquivo em backup_2025-07-04_15-13-22: menu.py

## Novo arquivo em backup_2025-07-04_15-13-22: score_manager.py

### Comparando com backup: backup_2025-07-04_15-14-02

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_15-14-02/app.py
@@ -1,43 +1,92 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Criar a tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula processo de carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua por código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    # Passa callback para menu para atualizar loading ao baixar ícone

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_15-14-02/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_15-14-02/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_15-14-02: button.py

## Novo arquivo em backup_2025-07-04_15-14-02: config.py

## Novo arquivo em backup_2025-07-04_15-14-02: controles.py

## Novo arquivo em backup_2025-07-04_15-14-02: loading.py

## Novo arquivo em backup_2025-07-04_15-14-02: menu.py

## Novo arquivo em backup_2025-07-04_15-14-02: score_manager.py

### Comparando com backup: backup_2025-07-04_15-14-24

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_15-14-24/app.py
@@ -1,43 +1,92 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Criar a tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula processo de carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua por código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    # Passa callback para menu para atualizar loading ao baixar ícone

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_15-14-24/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_15-14-24/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_15-14-24: button.py

## Novo arquivo em backup_2025-07-04_15-14-24: config.py

## Novo arquivo em backup_2025-07-04_15-14-24: controles.py

## Novo arquivo em backup_2025-07-04_15-14-24: loading.py

## Novo arquivo em backup_2025-07-04_15-14-24: menu.py

## Novo arquivo em backup_2025-07-04_15-14-24: score_manager.py

### Comparando com backup: backup_2025-07-04_15-17-22

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_15-17-22/app.py
@@ -1,43 +1,92 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Criar a tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula processo de carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua por código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    # Passa callback para menu para atualizar loading ao baixar ícone

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_15-17-22/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_15-17-22/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_15-17-22: button.py

## Novo arquivo em backup_2025-07-04_15-17-22: config.py

## Novo arquivo em backup_2025-07-04_15-17-22: controles.py

## Novo arquivo em backup_2025-07-04_15-17-22: loading.py

## Novo arquivo em backup_2025-07-04_15-17-22: menu.py

## Novo arquivo em backup_2025-07-04_15-17-22: score_manager.py

### Comparando com backup: backup_2025-07-04_15-18-25

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_15-18-25/app.py
@@ -1,43 +1,97 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Criar a tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula processo de carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.display.flip()  # Força a atualização da tela

+        pygame.event.pump()    # Processa eventos para não travar a janela

+        pygame.time.delay(700)  # Simula delay, substitua por código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    # Passa callback para menu para atualizar loading ao baixar ícone

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+        pygame.display.flip()

+        pygame.event.pump()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_15-18-25/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_15-18-25/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_15-18-25: button.py

## Novo arquivo em backup_2025-07-04_15-18-25: config.py

## Novo arquivo em backup_2025-07-04_15-18-25: controles.py

## Novo arquivo em backup_2025-07-04_15-18-25: loading.py

## Novo arquivo em backup_2025-07-04_15-18-25: menu.py

## Novo arquivo em backup_2025-07-04_15-18-25: score_manager.py

### Comparando com backup: backup_2025-07-04_15-18-57

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_15-18-57/app.py
@@ -1,43 +1,97 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Criar a tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula processo de carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.display.flip()  # Força a atualização da tela

+        pygame.event.pump()    # Processa eventos para não travar a janela

+        pygame.time.delay(700)  # Simula delay, substitua por código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    # Passa callback para menu para atualizar loading ao baixar ícone

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+        pygame.display.flip()

+        pygame.event.pump()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_15-18-57/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_15-18-57/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_15-18-57: button.py

## Novo arquivo em backup_2025-07-04_15-18-57: config.py

## Novo arquivo em backup_2025-07-04_15-18-57: controles.py

## Novo arquivo em backup_2025-07-04_15-18-57: loading.py

## Novo arquivo em backup_2025-07-04_15-18-57: menu.py

## Novo arquivo em backup_2025-07-04_15-18-57: score_manager.py

### Comparando com backup: backup_2025-07-04_15-19-15

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_15-19-15/app.py
@@ -1,43 +1,97 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Criar a tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula processo de carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.display.flip()  # Força a atualização da tela

+        pygame.event.pump()    # Processa eventos para não travar a janela

+        pygame.time.delay(700)  # Simula delay, substitua por código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    # Passa callback para menu para atualizar loading ao baixar ícone

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+        pygame.display.flip()

+        pygame.event.pump()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_15-19-15/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_15-19-15/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_15-19-15: button.py

## Novo arquivo em backup_2025-07-04_15-19-15: config.py

## Novo arquivo em backup_2025-07-04_15-19-15: controles.py

## Novo arquivo em backup_2025-07-04_15-19-15: loading.py

## Novo arquivo em backup_2025-07-04_15-19-15: menu.py

## Novo arquivo em backup_2025-07-04_15-19-15: score_manager.py

### Comparando com backup: backup_2025-07-04_15-21-46

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_15-21-46/app.py
@@ -1,43 +1,97 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Criar a tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula processo de carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.display.flip()  # Força a atualização da tela

+        pygame.event.pump()    # Processa eventos para não travar a janela

+        pygame.time.delay(700)  # Simula delay, substitua por código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    # Passa callback para menu para atualizar loading ao baixar ícone

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+        pygame.display.flip()

+        pygame.event.pump()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_15-21-46/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_15-21-46/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_15-21-46: button.py

## Novo arquivo em backup_2025-07-04_15-21-46: config.py

## Novo arquivo em backup_2025-07-04_15-21-46: controles.py

## Novo arquivo em backup_2025-07-04_15-21-46: loading.py

## Novo arquivo em backup_2025-07-04_15-21-46: menu.py

## Novo arquivo em backup_2025-07-04_15-21-46: score_manager.py

### Comparando com backup: backup_2025-07-04_15-25-35

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_15-25-35/app.py
@@ -1,43 +1,91 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, troque para código real se quiser

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        # Atualiza fade out da saída; se true, bloqueia resto do loop e continua fade

+        if config_menu.exit_handler.update_fade_out():

+            continue

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_15-25-35/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_15-25-35/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_15-25-35: button.py

## Novo arquivo em backup_2025-07-04_15-25-35: config.py

## Novo arquivo em backup_2025-07-04_15-25-35: controles.py

## Novo arquivo em backup_2025-07-04_15-25-35: exit_handler.py

## Novo arquivo em backup_2025-07-04_15-25-35: loading.py

## Novo arquivo em backup_2025-07-04_15-25-35: menu.py

## Novo arquivo em backup_2025-07-04_15-25-35: score_manager.py

### Comparando com backup: backup_2025-07-04_15-27-53

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_15-27-53/app.py
@@ -1,43 +1,91 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, troque para código real se quiser

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        # Atualiza fade out da saída; se true, bloqueia resto do loop e continua fade

+        if config_menu.exit_handler.update_fade_out():

+            continue

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_15-27-53/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_15-27-53/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_15-27-53: button.py

## Novo arquivo em backup_2025-07-04_15-27-53: config.py

## Novo arquivo em backup_2025-07-04_15-27-53: controles.py

## Novo arquivo em backup_2025-07-04_15-27-53: exit_handler.py

## Novo arquivo em backup_2025-07-04_15-27-53: loading.py

## Novo arquivo em backup_2025-07-04_15-27-53: menu.py

## Novo arquivo em backup_2025-07-04_15-27-53: score_manager.py

### Comparando com backup: backup_2025-07-04_15-29-21

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_15-29-21/app.py
@@ -1,43 +1,91 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, troque para código real se quiser

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        # Atualiza fade out da saída; se true, bloqueia resto do loop e continua fade

+        if config_menu.exit_handler.update_fade_out():

+            continue

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_15-29-21/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_15-29-21/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_15-29-21: button.py

## Novo arquivo em backup_2025-07-04_15-29-21: config.py

## Novo arquivo em backup_2025-07-04_15-29-21: controles.py

## Novo arquivo em backup_2025-07-04_15-29-21: exit_handler.py

## Novo arquivo em backup_2025-07-04_15-29-21: loading.py

## Novo arquivo em backup_2025-07-04_15-29-21: menu.py

## Novo arquivo em backup_2025-07-04_15-29-21: score_manager.py

### Comparando com backup: backup_2025-07-04_15-34-07

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_15-34-07/app.py
@@ -1,43 +1,110 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

+def fade_in(screen, duration=1000):

+    clock = pygame.time.Clock()

+    overlay = pygame.Surface(screen.get_size())

+    overlay.fill((0, 0, 0))

+    alpha = 255

+    step = 255 / (duration / 16)

 

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+    while alpha > 0:

+        overlay.set_alpha(int(alpha))

+        screen.blit(overlay, (0, 0))

+        pygame.display.flip()

+        clock.tick(60)

+        alpha -= step

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    steps = [

+        ("Carregando imagens...", 40),

+        ("Inicializando menus...", 60),

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(500)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    loading_screen.draw(80, "Carregando botão...")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, msg):

+        loading_screen.draw(percent, msg)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    loading_screen.draw(100, "Concluído!")

+    pygame.time.delay(500)

+    fade_in(screen)

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        if config_menu.exit_handler.update_fade_out():

+            continue

+

+        mouse_pos = pygame.mouse.get_pos()

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_15-34-07/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_15-34-07/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_15-34-07: button.py

## Novo arquivo em backup_2025-07-04_15-34-07: config.py

## Novo arquivo em backup_2025-07-04_15-34-07: controles.py

## Novo arquivo em backup_2025-07-04_15-34-07: exit_handler.py

## Novo arquivo em backup_2025-07-04_15-34-07: loading.py

## Novo arquivo em backup_2025-07-04_15-34-07: menu.py

## Novo arquivo em backup_2025-07-04_15-34-07: score_manager.py

### Comparando com backup: backup_2025-07-04_15-38-17

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_15-38-17/app.py
@@ -1,43 +1,95 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    steps = [

+        ("Carregando imagens...", 40),

+        ("Inicializando menus...", 60),

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(500)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    loading_screen.draw(80, "Carregando botão...")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, msg):

+        loading_screen.draw(percent, msg)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    loading_screen.draw(100, "Concluído!")

+    pygame.time.delay(500)

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        if config_menu.exit_handler.update_fade_out():

+            continue

+

+        mouse_pos = pygame.mouse.get_pos()

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_15-38-17/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_15-38-17/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_15-38-17: button.py

## Novo arquivo em backup_2025-07-04_15-38-17: config.py

## Novo arquivo em backup_2025-07-04_15-38-17: controles.py

## Novo arquivo em backup_2025-07-04_15-38-17: exit_handler.py

## Novo arquivo em backup_2025-07-04_15-38-17: loading.py

## Novo arquivo em backup_2025-07-04_15-38-17: menu.py

## Novo arquivo em backup_2025-07-04_15-38-17: score_manager.py

### Comparando com backup: backup_2025-07-04_15-39-32

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_15-39-32/app.py
@@ -1,43 +1,95 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    steps = [

+        ("Carregando imagens...", 40),

+        ("Inicializando menus...", 60),

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(500)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    loading_screen.draw(80, "Carregando botão...")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, msg):

+        loading_screen.draw(percent, msg)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    loading_screen.draw(100, "Concluído!")

+    pygame.time.delay(500)

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        if config_menu.exit_handler.update_fade_out():

+            continue

+

+        mouse_pos = pygame.mouse.get_pos()

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_15-39-32/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_15-39-32/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_15-39-32: button.py

## Novo arquivo em backup_2025-07-04_15-39-32: config.py

## Novo arquivo em backup_2025-07-04_15-39-32: controles.py

## Novo arquivo em backup_2025-07-04_15-39-32: exit_handler.py

## Novo arquivo em backup_2025-07-04_15-39-32: loading.py

## Novo arquivo em backup_2025-07-04_15-39-32: menu.py

## Novo arquivo em backup_2025-07-04_15-39-32: score_manager.py

### Comparando com backup: backup_2025-07-04_17-10-56

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-10-56/app.py
@@ -1,43 +1,95 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    steps = [

+        ("Carregando imagens...", 40),

+        ("Inicializando menus...", 60),

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(500)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    loading_screen.draw(80, "Carregando botão...")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, msg):

+        loading_screen.draw(percent, msg)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    loading_screen.draw(100, "Concluído!")

+    pygame.time.delay(500)

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        if config_menu.exit_handler.update_fade_out():

+            continue

+

+        mouse_pos = pygame.mouse.get_pos()

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-10-56/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-10-56/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-10-56: button.py

## Novo arquivo em backup_2025-07-04_17-10-56: config.py

## Novo arquivo em backup_2025-07-04_17-10-56: controles.py

## Novo arquivo em backup_2025-07-04_17-10-56: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-10-56: loading.py

## Novo arquivo em backup_2025-07-04_17-10-56: menu.py

## Novo arquivo em backup_2025-07-04_17-10-56: score_manager.py

### Comparando com backup: backup_2025-07-04_17-14-49

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-14-49/app.py
@@ -1,43 +1,108 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect  # NOVO

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Criar a tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula processo de carregamento com atualizações na tela de loading

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    click_effects = []  # Efeitos visuais de "+1"

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        # Adiciona efeito visual flutuante

+                        click_effects.append(ClickEffect(event.pos[0], event.pos[1], text="+1"))

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        # Desenha e atualiza os efeitos de clique

+        for effect in click_effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.is_expired():

+                click_effects.remove(effect)

+

+        # Fade-out ao sair

+        if config_menu.exit_handler.update_fade_out():

+            return

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-14-49/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-14-49/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-14-49: button.py

## Novo arquivo em backup_2025-07-04_17-14-49: click_effect.py

## Novo arquivo em backup_2025-07-04_17-14-49: config.py

## Novo arquivo em backup_2025-07-04_17-14-49: controles.py

## Novo arquivo em backup_2025-07-04_17-14-49: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-14-49: loading.py

## Novo arquivo em backup_2025-07-04_17-14-49: menu.py

## Novo arquivo em backup_2025-07-04_17-14-49: score_manager.py

### Comparando com backup: backup_2025-07-04_17-17-45

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-17-45/app.py
@@ -1,43 +1,108 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    click_effects = []

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    pontos_ganhos = 0

+                    for botao in [1, 2, 3]:

+                        if pygame.mouse.get_pressed()[botao - 1]:

+                            if config_menu.settings_menu.is_click_allowed(botao):

+                                pontos_ganhos += 1

+                    if pontos_ganhos > 0:

+                        button.click()

+                        score += pontos_ganhos

+                        click_effects.append(ClickEffect(event.pos[0], event.pos[1], text=f"+{pontos_ganhos}"))

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        # Atualiza e desenha efeitos de clique

+        for effect in click_effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                click_effects.remove(effect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        if config_menu.exit_handler.update_fade_out():

             break

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-17-45/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-17-45/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-17-45: button.py

## Novo arquivo em backup_2025-07-04_17-17-45: click_effect.py

## Novo arquivo em backup_2025-07-04_17-17-45: config.py

## Novo arquivo em backup_2025-07-04_17-17-45: controles.py

## Novo arquivo em backup_2025-07-04_17-17-45: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-17-45: loading.py

## Novo arquivo em backup_2025-07-04_17-17-45: menu.py

## Novo arquivo em backup_2025-07-04_17-17-45: score_manager.py

### Comparando com backup: backup_2025-07-04_17-18-31

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-18-31/app.py
@@ -1,43 +1,108 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    click_effects = []

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if button.is_clicked(event.pos):

+                    pontos_ganhos = 0

+                    for botao in [1, 2, 3]:

+                        if pygame.mouse.get_pressed()[botao - 1]:

+                            if config_menu.settings_menu.is_click_allowed(botao):

+                                pontos_ganhos += 1

+                    if pontos_ganhos > 0:

+                        button.click()

+                        score += pontos_ganhos

+                        click_effects.append(ClickEffect(event.pos[0], event.pos[1], text=f"+{pontos_ganhos}"))

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        # Atualiza e desenha efeitos de clique

+        for effect in click_effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                click_effects.remove(effect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        if config_menu.exit_handler.update_fade_out():

             break

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-18-31/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-18-31/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-18-31: button.py

## Novo arquivo em backup_2025-07-04_17-18-31: click_effect.py

## Novo arquivo em backup_2025-07-04_17-18-31: config.py

## Novo arquivo em backup_2025-07-04_17-18-31: controles.py

## Novo arquivo em backup_2025-07-04_17-18-31: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-18-31: loading.py

## Novo arquivo em backup_2025-07-04_17-18-31: menu.py

## Novo arquivo em backup_2025-07-04_17-18-31: score_manager.py

### Comparando com backup: backup_2025-07-04_17-20-28

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-20-28/app.py
@@ -1,43 +1,110 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    click_effects = []

+

+    # Função para atualizar tela de loading durante downloads

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+

+                        # Efeito visual para cada clique

+                        offset_x = [-10, 10, 0]  # deslocamento horizontal para clicks diferentes

+                        text = "+1"

+                        effect = ClickEffect(event.pos[0] + offset_x[event.button - 1], event.pos[1], text=text)

+                        click_effects.append(effect)

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Caixa de pontuação

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        # Desenhar efeitos visuais de clique

+        for effect in click_effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                click_effects.remove(effect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        if config_menu.exit_handler.update_fade_out():

             break

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-20-28/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-20-28/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-20-28: button.py

## Novo arquivo em backup_2025-07-04_17-20-28: click_effect.py

## Novo arquivo em backup_2025-07-04_17-20-28: config.py

## Novo arquivo em backup_2025-07-04_17-20-28: controles.py

## Novo arquivo em backup_2025-07-04_17-20-28: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-20-28: loading.py

## Novo arquivo em backup_2025-07-04_17-20-28: menu.py

## Novo arquivo em backup_2025-07-04_17-20-28: score_manager.py

### Comparando com backup: backup_2025-07-04_17-21-49

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-21-49/app.py
@@ -1,43 +1,114 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    click_effects = []

+    running = True

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+

+                        # Efeito visual com base no botão clicado

+                        click_value = event.button

+                        text = f"+{click_value}"

+                        offsets = {1: -10, 2: 10, 3: 0}

+                        offset = offsets.get(event.button, 0)

+

+                        effect = ClickEffect(event.pos[0] + offset, event.pos[1], text=text)

+                        click_effects.append(effect)

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Caixa de pontos

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        # Desenha efeitos de clique ativos

+        for effect in click_effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                click_effects.remove(effect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        if hasattr(config_menu, "exit_handler") and config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            continue

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-21-49/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-21-49/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-21-49: button.py

## Novo arquivo em backup_2025-07-04_17-21-49: click_effect.py

## Novo arquivo em backup_2025-07-04_17-21-49: config.py

## Novo arquivo em backup_2025-07-04_17-21-49: controles.py

## Novo arquivo em backup_2025-07-04_17-21-49: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-21-49: loading.py

## Novo arquivo em backup_2025-07-04_17-21-49: menu.py

## Novo arquivo em backup_2025-07-04_17-21-49: score_manager.py

### Comparando com backup: backup_2025-07-04_17-25-08

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-25-08/app.py
@@ -1,43 +1,114 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    click_effects = []

+    running = True

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+

+                        # Define o valor do clique com base no botão

+                        click_value = max(1, event.button) if event.button <= 3 else 1

+                        score += click_value

+

+                        # Exibição visual

+                        offset_x = {1: -10, 2: 10, 3: 20}

+                        offset = offset_x.get(event.button, 0)

+                        effect = ClickEffect(event.pos[0] + offset, event.pos[1], text=f"+{click_value}")

+                        click_effects.append(effect)

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Caixa de pontuação

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        # Atualiza efeitos

+        for effect in click_effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                click_effects.remove(effect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        if hasattr(config_menu, "exit_handler") and config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            continue

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-25-08/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-25-08/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-25-08: button.py

## Novo arquivo em backup_2025-07-04_17-25-08: click_effect.py

## Novo arquivo em backup_2025-07-04_17-25-08: config.py

## Novo arquivo em backup_2025-07-04_17-25-08: controles.py

## Novo arquivo em backup_2025-07-04_17-25-08: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-25-08: loading.py

## Novo arquivo em backup_2025-07-04_17-25-08: menu.py

## Novo arquivo em backup_2025-07-04_17-25-08: score_manager.py

### Comparando com backup: backup_2025-07-04_17-27-18

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-27-18/app.py
@@ -1,43 +1,121 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    click_effects = []

+

+    botoes_pressionados = set()

+    pontuou_no_frame = False  # controle para só pontuar 1 vez por frame

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+        pontuou_no_frame = False  # reseta a flag a cada frame

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                botoes_pressionados.add(event.button)

+

+                # Só pontua e mostra efeito se o clique foi no botão animado e não pontuou ainda neste frame

+                if not pontuou_no_frame and button.is_clicked(event.pos):

+                    button.click()

+                    pontos_para_adicionar = len(botoes_pressionados)

+                    score += pontos_para_adicionar

+

+                    # Exibe efeito visual com +N

+                    effect = ClickEffect(event.pos[0], event.pos[1], text=f"+{pontos_para_adicionar}")

+                    click_effects.append(effect)

+

+                    pontuou_no_frame = True  # evita pontuar múltiplas vezes por frame

+

+            elif event.type == pygame.MOUSEBUTTONUP:

+                if event.button in botoes_pressionados:

+                    botoes_pressionados.remove(event.button)

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Caixa de pontuação

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        for effect in click_effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                click_effects.remove(effect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        if hasattr(config_menu, "exit_handler") and config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            continue

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-27-18/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-27-18/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-27-18: button.py

## Novo arquivo em backup_2025-07-04_17-27-18: click_effect.py

## Novo arquivo em backup_2025-07-04_17-27-18: config.py

## Novo arquivo em backup_2025-07-04_17-27-18: controles.py

## Novo arquivo em backup_2025-07-04_17-27-18: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-27-18: loading.py

## Novo arquivo em backup_2025-07-04_17-27-18: menu.py

## Novo arquivo em backup_2025-07-04_17-27-18: score_manager.py

### Comparando com backup: backup_2025-07-04_17-29-11

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-29-11/app.py
@@ -1,43 +1,120 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    click_effects = []

+

+    botoes_pressionados = set()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+        pontuou_no_frame = False  # flag para só somar uma vez por frame

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                botoes_pressionados.add(event.button)

+

+                if not pontuou_no_frame and button.is_clicked(event.pos):

+                    button.click()

+                    pontos_para_adicionar = len(botoes_pressionados)

+                    score += pontos_para_adicionar

+

+                    # Criar efeito visual com tamanho e alpha proporcionais

+                    effect = ClickEffect(event.pos[0], event.pos[1], text=f"+{pontos_para_adicionar}")

+                    # Ajusta tamanho do texto para o número de cliques

+                    effect.text_size = 24 + 8 * pontos_para_adicionar

+                    click_effects.append(effect)

+

+                    pontuou_no_frame = True

+

+            elif event.type == pygame.MOUSEBUTTONUP:

+                botoes_pressionados.discard(event.button)

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        # Atualiza e desenha efeitos de clique, remove os finalizados

+        for effect in click_effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                click_effects.remove(effect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        if hasattr(config_menu, "exit_handler") and config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            continue

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-29-11/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-29-11/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-29-11: button.py

## Novo arquivo em backup_2025-07-04_17-29-11: click_effect.py

## Novo arquivo em backup_2025-07-04_17-29-11: config.py

## Novo arquivo em backup_2025-07-04_17-29-11: controles.py

## Novo arquivo em backup_2025-07-04_17-29-11: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-29-11: loading.py

## Novo arquivo em backup_2025-07-04_17-29-11: menu.py

## Novo arquivo em backup_2025-07-04_17-29-11: score_manager.py

### Comparando com backup: backup_2025-07-04_17-30-41

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-30-41/app.py
@@ -1,43 +1,117 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    click_effects = []

+

+    botoes_pressionados = set()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+        pontuou_no_frame = False  # flag para só somar uma vez por frame

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                botoes_pressionados.add(event.button)

+

+                if not pontuou_no_frame and button.is_clicked(event.pos):

+                    button.click()

+                    pontos_para_adicionar = len(botoes_pressionados)

+                    score += pontos_para_adicionar

+

+                    # Sempre mostra "+1 pontos", fixo, sem aumentar o tamanho do texto

+                    effect = ClickEffect(event.pos[0], event.pos[1], text="+1 pontos")

+                    click_effects.append(effect)

+

+                    pontuou_no_frame = True

+

+            elif event.type == pygame.MOUSEBUTTONUP:

+                botoes_pressionados.discard(event.button)

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        for effect in click_effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                click_effects.remove(effect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        if hasattr(config_menu, "exit_handler") and config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            continue

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-30-41/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-30-41/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-30-41: button.py

## Novo arquivo em backup_2025-07-04_17-30-41: click_effect.py

## Novo arquivo em backup_2025-07-04_17-30-41: config.py

## Novo arquivo em backup_2025-07-04_17-30-41: controles.py

## Novo arquivo em backup_2025-07-04_17-30-41: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-30-41: loading.py

## Novo arquivo em backup_2025-07-04_17-30-41: menu.py

## Novo arquivo em backup_2025-07-04_17-30-41: score_manager.py

### Comparando com backup: backup_2025-07-04_17-32-06

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-32-06/app.py
@@ -1,43 +1,122 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    click_effects = []

+

+    # Guarda botões pressionados para cada frame

+    botoes_pressionados = set()

+

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue

+            if event.type == pygame.QUIT:

+                running = False

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                botoes_pressionados.add(event.button)

+

+                # Se o clique for dentro do botão

+                if button.is_clicked(event.pos):

+                    button.click()

+

+                    # Quantidade de botões pressionados no momento do clique

+                    pontos_para_adicionar = len(botoes_pressionados)

+

+                    # Soma os pontos corretamente

+                    score += pontos_para_adicionar

+

+                    # Exibe sempre o texto "+1 pontos" fixo, uma vez só

+                    effect = ClickEffect(event.pos[0], event.pos[1], text="+1 pontos")

+                    click_effects.append(effect)

+

+            elif event.type == pygame.MOUSEBUTTONUP:

+                if event.button in botoes_pressionados:

+                    botoes_pressionados.remove(event.button)

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        # Atualiza e desenha os efeitos de clique, removendo os finalizados

+        for effect in click_effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                click_effects.remove(effect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        if hasattr(config_menu, "exit_handler") and config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            continue

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-32-06/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-32-06/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-32-06: button.py

## Novo arquivo em backup_2025-07-04_17-32-06: click_effect.py

## Novo arquivo em backup_2025-07-04_17-32-06: config.py

## Novo arquivo em backup_2025-07-04_17-32-06: controles.py

## Novo arquivo em backup_2025-07-04_17-32-06: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-32-06: loading.py

## Novo arquivo em backup_2025-07-04_17-32-06: menu.py

## Novo arquivo em backup_2025-07-04_17-32-06: score_manager.py

### Comparando com backup: backup_2025-07-04_17-34-07

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-34-07/app.py
@@ -1,43 +1,109 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

+class ClickEffect:

+    def __init__(self, x, y, text="+1 pontos"):

+        self.x = x

+        self.y = y

+        self.text = text

+        self.alpha = 255

+        self.dy = -1  # movimento vertical para cima

+        self.font = pygame.font.SysFont(None, 32)

+        self.finished = False

 

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

+    def update(self):

+        self.y += self.dy

+        self.alpha -= 5

+        if self.alpha <= 0:

+            self.alpha = 0

+            self.finished = True

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+    def draw(self, screen):

+        if self.alpha > 0:

+            text_surface = self.font.render(self.text, True, (255, 100, 100))

+            text_surface.set_alpha(self.alpha)

+            screen.blit(text_surface, (self.x, self.y))

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    click_effects = []

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        # Sempre soma 1 ponto por clique, independente do botão

+                        score += 1

+                        # Cria efeito visual de +1 pontos na posição do clique

+                        effect = ClickEffect(event.pos[0], event.pos[1], text="+1 pontos")

+                        click_effects.append(effect)

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Atualiza e desenha os efeitos de clique

+        for effect in click_effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                click_effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-34-07/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-34-07/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-34-07: button.py

## Novo arquivo em backup_2025-07-04_17-34-07: click_effect.py

## Novo arquivo em backup_2025-07-04_17-34-07: config.py

## Novo arquivo em backup_2025-07-04_17-34-07: controles.py

## Novo arquivo em backup_2025-07-04_17-34-07: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-34-07: loading.py

## Novo arquivo em backup_2025-07-04_17-34-07: menu.py

## Novo arquivo em backup_2025-07-04_17-34-07: score_manager.py

### Comparando com backup: backup_2025-07-04_17-35-50

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-35-50/app.py
@@ -1,43 +1,110 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

+class ClickEffect:

+    def __init__(self, x, y, text="+1 pontos"):

+        self.x = x

+        self.y = y

+        self.text = text

+        self.alpha = 255

+        self.dy = -0.5  # movimento vertical para cima mais suave e lento

+        self.font = pygame.font.SysFont(None, 32)

+        self.finished = False

+        # Pré-renderiza o texto para evitar recriação todo frame

+        self.text_surface = self.font.render(self.text, True, (255, 100, 100))

 

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

+    def update(self):

+        self.y += self.dy

+        self.alpha -= 3  # decaimento mais lento para maior fluidez

+        if self.alpha <= 0:

+            self.alpha = 0

+            self.finished = True

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+    def draw(self, screen):

+        if self.alpha > 0:

+            # Usa uma cópia para ajustar alpha sem recriar toda hora

+            surface = self.text_surface.copy()

+            surface.set_alpha(self.alpha)

+            screen.blit(surface, (self.x, self.y))

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    click_effects = []

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        dt = clock.tick(60) / 1000  # delta time em segundos (não obrigatório mas útil p/ futuros ajustes)

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effect = ClickEffect(event.pos[0], event.pos[1], text="+1 pontos")

+                        click_effects.append(effect)

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Atualiza e desenha os efeitos de clique

+        for effect in click_effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                click_effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"ponto: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-35-50/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-35-50/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-35-50: button.py

## Novo arquivo em backup_2025-07-04_17-35-50: click_effect.py

## Novo arquivo em backup_2025-07-04_17-35-50: config.py

## Novo arquivo em backup_2025-07-04_17-35-50: controles.py

## Novo arquivo em backup_2025-07-04_17-35-50: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-35-50: loading.py

## Novo arquivo em backup_2025-07-04_17-35-50: menu.py

## Novo arquivo em backup_2025-07-04_17-35-50: score_manager.py

### Comparando com backup: backup_2025-07-04_17-36-43

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-36-43/app.py
@@ -1,43 +1,110 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

+class ClickEffect:

+    def __init__(self, x, y, text="+1 pontos"):

+        self.x = x

+        self.y = y

+        self.text = text

+        self.alpha = 255

+        self.dy = -0.5  # movimento vertical para cima mais suave e lento

+        self.font = pygame.font.SysFont(None, 32)

+        self.finished = False

+        # Pré-renderiza o texto para evitar recriação todo frame

+        self.text_surface = self.font.render(self.text, True, (255, 100, 100))

 

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

+    def update(self):

+        self.y += self.dy

+        self.alpha -= 3  # decaimento mais lento para maior fluidez

+        if self.alpha <= 0:

+            self.alpha = 0

+            self.finished = True

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+    def draw(self, screen):

+        if self.alpha > 0:

+            # Usa uma cópia para ajustar alpha sem recriar toda hora

+            surface = self.text_surface.copy()

+            surface.set_alpha(self.alpha)

+            screen.blit(surface, (self.x, self.y))

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    click_effects = []

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        dt = clock.tick(60) / 1000  # delta time em segundos (não obrigatório mas útil p/ futuros ajustes)

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effect = ClickEffect(event.pos[0], event.pos[1], text="+1 ponto")

+                        click_effects.append(effect)

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Atualiza e desenha os efeitos de clique

+        for effect in click_effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                click_effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"ponto: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-36-43/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-36-43/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-36-43: button.py

## Novo arquivo em backup_2025-07-04_17-36-43: click_effect.py

## Novo arquivo em backup_2025-07-04_17-36-43: config.py

## Novo arquivo em backup_2025-07-04_17-36-43: controles.py

## Novo arquivo em backup_2025-07-04_17-36-43: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-36-43: loading.py

## Novo arquivo em backup_2025-07-04_17-36-43: menu.py

## Novo arquivo em backup_2025-07-04_17-36-43: score_manager.py

### Comparando com backup: backup_2025-07-04_17-42-17

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-42-17/app.py
@@ -1,43 +1,110 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

+class ClickEffect:

+    def __init__(self, x, y, text="+1 pontos"):

+        self.x = x

+        self.y = y

+        self.text = text

+        self.alpha = 255

+        self.dy = -0.5  # movimento vertical para cima mais suave e lento

+        self.font = pygame.font.SysFont(None, 32)

+        self.finished = False

+        # Pré-renderiza o texto para evitar recriação todo frame

+        self.text_surface = self.font.render(self.text, True, (255, 100, 100))

 

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

+    def update(self):

+        self.y += self.dy

+        self.alpha -= 3  # decaimento mais lento para maior fluidez

+        if self.alpha <= 0:

+            self.alpha = 0

+            self.finished = True

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+    def draw(self, screen):

+        if self.alpha > 0:

+            # Usa uma cópia para ajustar alpha sem recriar toda hora

+            surface = self.text_surface.copy()

+            surface.set_alpha(self.alpha)

+            screen.blit(surface, (self.x, self.y))

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    click_effects = []

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        dt = clock.tick(60) / 1000  # delta time em segundos (não obrigatório mas útil p/ futuros ajustes)

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effect = ClickEffect(event.pos[0], event.pos[1], text="+1 ponto")

+                        click_effects.append(effect)

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Atualiza e desenha os efeitos de clique

+        for effect in click_effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                click_effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"ponto: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-42-17/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-42-17/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-42-17: button.py

## Novo arquivo em backup_2025-07-04_17-42-17: click_effect.py

## Novo arquivo em backup_2025-07-04_17-42-17: config.py

## Novo arquivo em backup_2025-07-04_17-42-17: controles.py

## Novo arquivo em backup_2025-07-04_17-42-17: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-42-17: loading.py

## Novo arquivo em backup_2025-07-04_17-42-17: menu.py

## Novo arquivo em backup_2025-07-04_17-42-17: score_manager.py

### Comparando com backup: backup_2025-07-04_17-43-18

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-43-18/app.py
@@ -1,43 +1,110 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

+class ClickEffect:

+    def __init__(self, x, y, text="+1 pontos"):

+        self.x = x

+        self.y = y

+        self.text = text

+        self.alpha = 255

+        self.dy = -0.5  # movimento vertical para cima mais suave e lento

+        self.font = pygame.font.SysFont(None, 32)

+        self.finished = False

+        # Pré-renderiza o texto para evitar recriação todo frame

+        self.text_surface = self.font.render(self.text, True, (255, 100, 100))

 

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

+    def update(self):

+        self.y += self.dy

+        self.alpha -= 3  # decaimento mais lento para maior fluidez

+        if self.alpha <= 0:

+            self.alpha = 0

+            self.finished = True

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+    def draw(self, screen):

+        if self.alpha > 0:

+            # Usa uma cópia para ajustar alpha sem recriar toda hora

+            surface = self.text_surface.copy()

+            surface.set_alpha(self.alpha)

+            screen.blit(surface, (self.x, self.y))

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    click_effects = []

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        dt = clock.tick(60) / 1000  # delta time em segundos (não obrigatório mas útil p/ futuros ajustes)

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effect = ClickEffect(event.pos[0], event.pos[1], text="+1 ponto")

+                        click_effects.append(effect)

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Atualiza e desenha os efeitos de clique

+        for effect in click_effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                click_effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"ponto: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-43-18/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-43-18/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-43-18: button.py

## Novo arquivo em backup_2025-07-04_17-43-18: click_effect.py

## Novo arquivo em backup_2025-07-04_17-43-18: config.py

## Novo arquivo em backup_2025-07-04_17-43-18: controles.py

## Novo arquivo em backup_2025-07-04_17-43-18: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-43-18: loading.py

## Novo arquivo em backup_2025-07-04_17-43-18: menu.py

## Novo arquivo em backup_2025-07-04_17-43-18: score_manager.py

### Comparando com backup: backup_2025-07-04_17-45-20

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-45-20/app.py
@@ -1,43 +1,110 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

+class ClickEffect:

+    def __init__(self, x, y, text="+1 pontos"):

+        self.x = x

+        self.y = y

+        self.text = text

+        self.alpha = 255

+        self.dy = -0.5  # movimento vertical para cima mais suave e lento

+        self.font = pygame.font.SysFont(None, 32)

+        self.finished = False

+        # Pré-renderiza o texto para evitar recriação todo frame

+        self.text_surface = self.font.render(self.text, True, (255, 100, 100))

 

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

+    def update(self):

+        self.y += self.dy

+        self.alpha -= 3  # decaimento mais lento para maior fluidez

+        if self.alpha <= 0:

+            self.alpha = 0

+            self.finished = True

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+    def draw(self, screen):

+        if self.alpha > 0:

+            # Usa uma cópia para ajustar alpha sem recriar toda hora

+            surface = self.text_surface.copy()

+            surface.set_alpha(self.alpha)

+            screen.blit(surface, (self.x, self.y))

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    click_effects = []

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        dt = clock.tick(60) / 1000  # delta time em segundos (não obrigatório mas útil p/ futuros ajustes)

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effect = ClickEffect(event.pos[0], event.pos[1], text="+1 ponto")

+                        click_effects.append(effect)

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Atualiza e desenha os efeitos de clique

+        for effect in click_effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                click_effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"ponto: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-45-20/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-45-20/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-45-20: button.py

## Novo arquivo em backup_2025-07-04_17-45-20: click_effect.py

## Novo arquivo em backup_2025-07-04_17-45-20: config.py

## Novo arquivo em backup_2025-07-04_17-45-20: controles.py

## Novo arquivo em backup_2025-07-04_17-45-20: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-45-20: loading.py

## Novo arquivo em backup_2025-07-04_17-45-20: menu.py

## Novo arquivo em backup_2025-07-04_17-45-20: score_manager.py

### Comparando com backup: backup_2025-07-04_17-46-30

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-46-30/app.py
@@ -1,43 +1,110 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

+class ClickEffect:

+    def __init__(self, x, y, text="+1 pontos"):

+        self.x = x

+        self.y = y

+        self.text = text

+        self.alpha = 255

+        self.dy = -0.5  # movimento vertical para cima mais suave e lento

+        self.font = pygame.font.SysFont(None, 32)

+        self.finished = False

+        # Pré-renderiza o texto para evitar recriação todo frame

+        self.text_surface = self.font.render(self.text, True, (255, 100, 100))

 

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

+    def update(self):

+        self.y += self.dy

+        self.alpha -= 3  # decaimento mais lento para maior fluidez

+        if self.alpha <= 0:

+            self.alpha = 0

+            self.finished = True

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+    def draw(self, screen):

+        if self.alpha > 0:

+            # Usa uma cópia para ajustar alpha sem recriar toda hora

+            surface = self.text_surface.copy()

+            surface.set_alpha(self.alpha)

+            screen.blit(surface, (self.x, self.y))

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    click_effects = []

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        dt = clock.tick(60) / 1000  # delta time em segundos (não obrigatório mas útil p/ futuros ajustes)

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effect = ClickEffect(event.pos[0], event.pos[1], text="+1 ponto")

+                        click_effects.append(effect)

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Atualiza e desenha os efeitos de clique

+        for effect in click_effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                click_effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"ponto: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-46-30/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-46-30/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-46-30: button.py

## Novo arquivo em backup_2025-07-04_17-46-30: click_effect.py

## Novo arquivo em backup_2025-07-04_17-46-30: config.py

## Novo arquivo em backup_2025-07-04_17-46-30: controles.py

## Novo arquivo em backup_2025-07-04_17-46-30: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-46-30: loading.py

## Novo arquivo em backup_2025-07-04_17-46-30: menu.py

## Novo arquivo em backup_2025-07-04_17-46-30: score_manager.py

### Comparando com backup: backup_2025-07-04_17-49-05

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-49-05/app.py
@@ -1,43 +1,77 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        if config_menu.exit_handler.update_fade_out():

+            # Enquanto estiver saindo (fade out) não processa mais o jogo

+            continue

+

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-49-05/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-49-05/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-49-05: button.py

## Novo arquivo em backup_2025-07-04_17-49-05: click_effect.py

## Novo arquivo em backup_2025-07-04_17-49-05: config.py

## Novo arquivo em backup_2025-07-04_17-49-05: controles.py

## Novo arquivo em backup_2025-07-04_17-49-05: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-49-05: loading.py

## Novo arquivo em backup_2025-07-04_17-49-05: menu.py

## Novo arquivo em backup_2025-07-04_17-49-05: score_manager.py

### Comparando com backup: backup_2025-07-04_17-49-20

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-49-20/app.py
@@ -1,43 +1,77 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        if config_menu.exit_handler.update_fade_out():

+            # Enquanto estiver saindo (fade out) não processa mais o jogo

+            continue

+

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-49-20/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-49-20/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-49-20: button.py

## Novo arquivo em backup_2025-07-04_17-49-20: click_effect.py

## Novo arquivo em backup_2025-07-04_17-49-20: config.py

## Novo arquivo em backup_2025-07-04_17-49-20: controles.py

## Novo arquivo em backup_2025-07-04_17-49-20: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-49-20: loading.py

## Novo arquivo em backup_2025-07-04_17-49-20: menu.py

## Novo arquivo em backup_2025-07-04_17-49-20: score_manager.py

### Comparando com backup: backup_2025-07-04_17-51-19

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-51-19/app.py
@@ -1,43 +1,77 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        if config_menu.exit_handler.update_fade_out():

+            # Enquanto estiver saindo (fade out) não processa mais o jogo

+            continue

+

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-51-19/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-51-19/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-51-19: button.py

## Novo arquivo em backup_2025-07-04_17-51-19: click_effect.py

## Novo arquivo em backup_2025-07-04_17-51-19: config.py

## Novo arquivo em backup_2025-07-04_17-51-19: controles.py

## Novo arquivo em backup_2025-07-04_17-51-19: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-51-19: loading.py

## Novo arquivo em backup_2025-07-04_17-51-19: menu.py

## Novo arquivo em backup_2025-07-04_17-51-19: score_manager.py

### Comparando com backup: backup_2025-07-04_17-54-16

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-54-16/app.py
@@ -1,43 +1,86 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from exit_handler import ExitHandler

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    exit_handler = ExitHandler(screen, WIDTH, HEIGHT)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, exit_handler=exit_handler)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            # Se exit_handler está ativo, ele consome eventos prioritariamente

+            if exit_handler.active:

+                if exit_handler.handle_event(event):

+                    continue

+            elif config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        # Se o exit_handler está ativo, desenha e atualiza fade

+        if exit_handler.active or exit_handler.fading_out:

+            exit_handler.draw()

+            exit_handler.update_fade_out()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-54-16/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-54-16/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-54-16: button.py

## Novo arquivo em backup_2025-07-04_17-54-16: click_effect.py

## Novo arquivo em backup_2025-07-04_17-54-16: config.py

## Novo arquivo em backup_2025-07-04_17-54-16: controles.py

## Novo arquivo em backup_2025-07-04_17-54-16: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-54-16: loading.py

## Novo arquivo em backup_2025-07-04_17-54-16: menu.py

## Novo arquivo em backup_2025-07-04_17-54-16: score_manager.py

### Comparando com backup: backup_2025-07-04_17-56-33

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-56-33/app.py
@@ -1,43 +1,86 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from exit_handler import ExitHandler

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    exit_handler = ExitHandler(screen, WIDTH, HEIGHT)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, exit_handler=exit_handler)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            # Se exit_handler está ativo, ele consome eventos prioritariamente

+            if exit_handler.active:

+                if exit_handler.handle_event(event):

+                    continue

+            elif config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+

+            if event.type == pygame.QUIT:

+                running = False

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        # Se o exit_handler está ativo, desenha e atualiza fade

+        if exit_handler.active or exit_handler.fading_out:

+            exit_handler.draw()

+            exit_handler.update_fade_out()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-56-33/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-56-33/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-56-33: button.py

## Novo arquivo em backup_2025-07-04_17-56-33: click_effect.py

## Novo arquivo em backup_2025-07-04_17-56-33: config.py

## Novo arquivo em backup_2025-07-04_17-56-33: controles.py

## Novo arquivo em backup_2025-07-04_17-56-33: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-56-33: loading.py

## Novo arquivo em backup_2025-07-04_17-56-33: menu.py

## Novo arquivo em backup_2025-07-04_17-56-33: score_manager.py

### Comparando com backup: backup_2025-07-04_17-57-49

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-57-49/app.py
@@ -1,43 +1,116 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua pelo código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    # Callback para carregar ícone no menu de configurações

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    # Cria o menu (sem passar exit_handler, pois é interno)

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    fade_out_alpha = 0

+    fading_out = False

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+

+            if fading_out:

+                # Se estiver fazendo fade out, ignore inputs

+                continue

+

+            if event.type == pygame.QUIT:

+                fading_out = True  # inicia fade out

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        # Se fade out ativado, desenha fade e termina quando completamente preto

+        if fading_out:

+            fade_out_alpha += 8  # velocidade do fade out, ajuste se quiser

+            if fade_out_alpha > 255:

+                fade_out_alpha = 255

+            fade_surface = pygame.Surface((WIDTH, HEIGHT))

+            fade_surface.set_alpha(fade_out_alpha)

+            fade_surface.fill((0, 0, 0))

+            screen.blit(fade_surface, (0, 0))

+            if fade_out_alpha >= 255:

+                running = False

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-57-49/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-57-49/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-57-49: button.py

## Novo arquivo em backup_2025-07-04_17-57-49: click_effect.py

## Novo arquivo em backup_2025-07-04_17-57-49: config.py

## Novo arquivo em backup_2025-07-04_17-57-49: controles.py

## Novo arquivo em backup_2025-07-04_17-57-49: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-57-49: loading.py

## Novo arquivo em backup_2025-07-04_17-57-49: menu.py

## Novo arquivo em backup_2025-07-04_17-57-49: score_manager.py

### Comparando com backup: backup_2025-07-04_17-58-15

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-58-15/app.py
@@ -1,43 +1,116 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua pelo código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    # Callback para carregar ícone no menu de configurações

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    # Cria o menu (sem passar exit_handler, pois é interno)

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    fade_out_alpha = 0

+    fading_out = False

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+

+            if fading_out:

+                # Se estiver fazendo fade out, ignore inputs

+                continue

+

+            if event.type == pygame.QUIT:

+                fading_out = True  # inicia fade out

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        # Se fade out ativado, desenha fade e termina quando completamente preto

+        if fading_out:

+            fade_out_alpha += 8  # velocidade do fade out, ajuste se quiser

+            if fade_out_alpha > 255:

+                fade_out_alpha = 255

+            fade_surface = pygame.Surface((WIDTH, HEIGHT))

+            fade_surface.set_alpha(fade_out_alpha)

+            fade_surface.fill((0, 0, 0))

+            screen.blit(fade_surface, (0, 0))

+            if fade_out_alpha >= 255:

+                running = False

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-58-15/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-58-15/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-58-15: button.py

## Novo arquivo em backup_2025-07-04_17-58-15: click_effect.py

## Novo arquivo em backup_2025-07-04_17-58-15: config.py

## Novo arquivo em backup_2025-07-04_17-58-15: controles.py

## Novo arquivo em backup_2025-07-04_17-58-15: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-58-15: loading.py

## Novo arquivo em backup_2025-07-04_17-58-15: menu.py

## Novo arquivo em backup_2025-07-04_17-58-15: score_manager.py

### Comparando com backup: backup_2025-07-04_17-59-48

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_17-59-48/app.py
@@ -1,43 +1,116 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua pelo código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    # Callback para carregar ícone no menu de configurações

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    # Cria o menu (sem passar exit_handler, pois é interno)

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    fade_out_alpha = 0

+    fading_out = False

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+

+            if fading_out:

+                # Se estiver fazendo fade out, ignore inputs

+                continue

+

+            if event.type == pygame.QUIT:

+                fading_out = True  # inicia fade out

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        # Se fade out ativado, desenha fade e termina quando completamente preto

+        if fading_out:

+            fade_out_alpha += 8  # velocidade do fade out, ajuste se quiser

+            if fade_out_alpha > 255:

+                fade_out_alpha = 255

+            fade_surface = pygame.Surface((WIDTH, HEIGHT))

+            fade_surface.set_alpha(fade_out_alpha)

+            fade_surface.fill((0, 0, 0))

+            screen.blit(fade_surface, (0, 0))

+            if fade_out_alpha >= 255:

+                running = False

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_17-59-48/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_17-59-48/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_17-59-48: button.py

## Novo arquivo em backup_2025-07-04_17-59-48: click_effect.py

## Novo arquivo em backup_2025-07-04_17-59-48: config.py

## Novo arquivo em backup_2025-07-04_17-59-48: controles.py

## Novo arquivo em backup_2025-07-04_17-59-48: exit_handler.py

## Novo arquivo em backup_2025-07-04_17-59-48: loading.py

## Novo arquivo em backup_2025-07-04_17-59-48: menu.py

## Novo arquivo em backup_2025-07-04_17-59-48: score_manager.py

### Comparando com backup: backup_2025-07-04_18-00-58

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-00-58/app.py
@@ -1,43 +1,116 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua pelo código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    # Callback para carregar ícone no menu de configurações

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    # Cria o menu (sem passar exit_handler, pois é interno)

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    fade_out_alpha = 0

+    fading_out = False

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+

+            if fading_out:

+                # Se estiver fazendo fade out, ignore inputs

+                continue

+

+            if event.type == pygame.QUIT:

+                fading_out = True  # inicia fade out

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        # Se fade out ativado, desenha fade e termina quando completamente preto

+        if fading_out:

+            fade_out_alpha += 8  # velocidade do fade out, ajuste se quiser

+            if fade_out_alpha > 255:

+                fade_out_alpha = 255

+            fade_surface = pygame.Surface((WIDTH, HEIGHT))

+            fade_surface.set_alpha(fade_out_alpha)

+            fade_surface.fill((0, 0, 0))

+            screen.blit(fade_surface, (0, 0))

+            if fade_out_alpha >= 255:

+                running = False

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-00-58/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-00-58/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-00-58: button.py

## Novo arquivo em backup_2025-07-04_18-00-58: click_effect.py

## Novo arquivo em backup_2025-07-04_18-00-58: config.py

## Novo arquivo em backup_2025-07-04_18-00-58: controles.py

## Novo arquivo em backup_2025-07-04_18-00-58: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-00-58: loading.py

## Novo arquivo em backup_2025-07-04_18-00-58: menu.py

## Novo arquivo em backup_2025-07-04_18-00-58: score_manager.py

### Comparando com backup: backup_2025-07-04_18-02-52

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-02-52/app.py
@@ -1,43 +1,116 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua pelo código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    # Callback para carregar ícone no menu de configurações

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    # Cria o menu (sem passar exit_handler, pois é interno)

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    fade_out_alpha = 0

+    fading_out = False

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+

+            if fading_out:

+                # Se estiver fazendo fade out, ignore inputs

+                continue

+

+            if event.type == pygame.QUIT:

+                fading_out = True  # inicia fade out

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        # Se fade out ativado, desenha fade e termina quando completamente preto

+        if fading_out:

+            fade_out_alpha += 8  # velocidade do fade out, ajuste se quiser

+            if fade_out_alpha > 255:

+                fade_out_alpha = 255

+            fade_surface = pygame.Surface((WIDTH, HEIGHT))

+            fade_surface.set_alpha(fade_out_alpha)

+            fade_surface.fill((0, 0, 0))

+            screen.blit(fade_surface, (0, 0))

+            if fade_out_alpha >= 255:

+                running = False

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-02-52/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-02-52/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-02-52: button.py

## Novo arquivo em backup_2025-07-04_18-02-52: click_effect.py

## Novo arquivo em backup_2025-07-04_18-02-52: config.py

## Novo arquivo em backup_2025-07-04_18-02-52: controles.py

## Novo arquivo em backup_2025-07-04_18-02-52: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-02-52: loading.py

## Novo arquivo em backup_2025-07-04_18-02-52: menu.py

## Novo arquivo em backup_2025-07-04_18-02-52: score_manager.py

### Comparando com backup: backup_2025-07-04_18-04-30

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-04-30/app.py
@@ -1,43 +1,116 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua pelo código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    # Callback para carregar ícone no menu de configurações

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    # Cria o menu (sem passar exit_handler, pois é interno)

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    fade_out_alpha = 0

+    fading_out = False

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+

+            if fading_out:

+                # Se estiver fazendo fade out, ignore inputs

+                continue

+

+            if event.type == pygame.QUIT:

+                fading_out = True  # inicia fade out

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        # Se fade out ativado, desenha fade e termina quando completamente preto

+        if fading_out:

+            fade_out_alpha += 8  # velocidade do fade out, ajuste se quiser

+            if fade_out_alpha > 255:

+                fade_out_alpha = 255

+            fade_surface = pygame.Surface((WIDTH, HEIGHT))

+            fade_surface.set_alpha(fade_out_alpha)

+            fade_surface.fill((0, 0, 0))

+            screen.blit(fade_surface, (0, 0))

+            if fade_out_alpha >= 255:

+                running = False

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-04-30/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-04-30/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-04-30: button.py

## Novo arquivo em backup_2025-07-04_18-04-30: click_effect.py

## Novo arquivo em backup_2025-07-04_18-04-30: config.py

## Novo arquivo em backup_2025-07-04_18-04-30: controles.py

## Novo arquivo em backup_2025-07-04_18-04-30: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-04-30: loading.py

## Novo arquivo em backup_2025-07-04_18-04-30: menu.py

## Novo arquivo em backup_2025-07-04_18-04-30: score_manager.py

### Comparando com backup: backup_2025-07-04_18-05-51

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-05-51/app.py
@@ -1,43 +1,116 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua pelo código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    # Callback para carregar ícone no menu de configurações

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    # Cria o menu (sem passar exit_handler, pois é interno)

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    fade_out_alpha = 0

+    fading_out = False

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        for event in pygame.event.get():

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+

+            if fading_out:

+                # Se estiver fazendo fade out, ignore inputs

+                continue

+

+            if event.type == pygame.QUIT:

+                fading_out = True  # inicia fade out

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        # Se fade out ativado, desenha fade e termina quando completamente preto

+        if fading_out:

+            fade_out_alpha += 8  # velocidade do fade out, ajuste se quiser

+            if fade_out_alpha > 255:

+                fade_out_alpha = 255

+            fade_surface = pygame.Surface((WIDTH, HEIGHT))

+            fade_surface.set_alpha(fade_out_alpha)

+            fade_surface.fill((0, 0, 0))

+            screen.blit(fade_surface, (0, 0))

+            if fade_out_alpha >= 255:

+                running = False

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-05-51/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-05-51/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-05-51: button.py

## Novo arquivo em backup_2025-07-04_18-05-51: click_effect.py

## Novo arquivo em backup_2025-07-04_18-05-51: config.py

## Novo arquivo em backup_2025-07-04_18-05-51: controles.py

## Novo arquivo em backup_2025-07-04_18-05-51: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-05-51: loading.py

## Novo arquivo em backup_2025-07-04_18-05-51: menu.py

## Novo arquivo em backup_2025-07-04_18-05-51: score_manager.py

### Comparando com backup: backup_2025-07-04_18-07-02

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-07-02/app.py
@@ -1,43 +1,110 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua pelo código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        # Atualiza fade out do exit handler e se estiver ativo, trava o jogo até fechar

+        if config_menu.exit_handler.update_fade_out():

+            # fade rolando e no fim fecha o jogo, não processa eventos

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            # Se o menu exit_handler está ativo, ele consome todos os eventos

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+

+            if event.type == pygame.QUIT:

+                # Ao tentar fechar pelo botão X, abre menu sair

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-07-02/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-07-02/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-07-02: button.py

## Novo arquivo em backup_2025-07-04_18-07-02: click_effect.py

## Novo arquivo em backup_2025-07-04_18-07-02: config.py

## Novo arquivo em backup_2025-07-04_18-07-02: controles.py

## Novo arquivo em backup_2025-07-04_18-07-02: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-07-02: loading.py

## Novo arquivo em backup_2025-07-04_18-07-02: menu.py

## Novo arquivo em backup_2025-07-04_18-07-02: score_manager.py

### Comparando com backup: backup_2025-07-04_18-08-46

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-08-46/app.py
@@ -1,43 +1,110 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua pelo código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        # Atualiza fade out do exit handler e se estiver ativo, trava o jogo até fechar

+        if config_menu.exit_handler.update_fade_out():

+            # fade rolando e no fim fecha o jogo, não processa eventos

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            # Se o menu exit_handler está ativo, ele consome todos os eventos

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+

+            if event.type == pygame.QUIT:

+                # Ao tentar fechar pelo botão X, abre menu sair

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-08-46/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-08-46/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-08-46: button.py

## Novo arquivo em backup_2025-07-04_18-08-46: click_effect.py

## Novo arquivo em backup_2025-07-04_18-08-46: config.py

## Novo arquivo em backup_2025-07-04_18-08-46: controles.py

## Novo arquivo em backup_2025-07-04_18-08-46: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-08-46: loading.py

## Novo arquivo em backup_2025-07-04_18-08-46: menu.py

## Novo arquivo em backup_2025-07-04_18-08-46: score_manager.py

### Comparando com backup: backup_2025-07-04_18-10-19

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-10-19/app.py
@@ -1,43 +1,110 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua pelo código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        # Atualiza fade out do exit handler e se estiver ativo, trava o jogo até fechar

+        if config_menu.exit_handler.update_fade_out():

+            # fade rolando e no fim fecha o jogo, não processa eventos

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            # Se o menu exit_handler está ativo, ele consome todos os eventos

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+

+            if event.type == pygame.QUIT:

+                # Ao tentar fechar pelo botão X, abre menu sair

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-10-19/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-10-19/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-10-19: button.py

## Novo arquivo em backup_2025-07-04_18-10-19: click_effect.py

## Novo arquivo em backup_2025-07-04_18-10-19: config.py

## Novo arquivo em backup_2025-07-04_18-10-19: controles.py

## Novo arquivo em backup_2025-07-04_18-10-19: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-10-19: loading.py

## Novo arquivo em backup_2025-07-04_18-10-19: menu.py

## Novo arquivo em backup_2025-07-04_18-10-19: score_manager.py

### Comparando com backup: backup_2025-07-04_18-12-05

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-12-05/app.py
@@ -1,43 +1,110 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua pelo código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        # Atualiza fade out do exit handler e se estiver ativo, trava o jogo até fechar

+        if config_menu.exit_handler.update_fade_out():

+            # fade rolando e no fim fecha o jogo, não processa eventos

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            # Se o menu exit_handler está ativo, ele consome todos os eventos

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+

+            if event.type == pygame.QUIT:

+                # Ao tentar fechar pelo botão X, abre menu sair

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-12-05/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-12-05/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-12-05: button.py

## Novo arquivo em backup_2025-07-04_18-12-05: click_effect.py

## Novo arquivo em backup_2025-07-04_18-12-05: config.py

## Novo arquivo em backup_2025-07-04_18-12-05: controles.py

## Novo arquivo em backup_2025-07-04_18-12-05: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-12-05: loading.py

## Novo arquivo em backup_2025-07-04_18-12-05: menu.py

## Novo arquivo em backup_2025-07-04_18-12-05: score_manager.py

### Comparando com backup: backup_2025-07-04_18-15-13

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-15-13/app.py
@@ -1,43 +1,110 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua pelo código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        # Atualiza fade out do exit handler e se estiver ativo, trava o jogo até fechar

+        if config_menu.exit_handler.update_fade_out():

+            # fade rolando e no fim fecha o jogo, não processa eventos

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            # Se o menu exit_handler está ativo, ele consome todos os eventos

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+

+            if event.type == pygame.QUIT:

+                # Ao tentar fechar pelo botão X, abre menu sair

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-15-13/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-15-13/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-15-13: button.py

## Novo arquivo em backup_2025-07-04_18-15-13: click_effect.py

## Novo arquivo em backup_2025-07-04_18-15-13: config.py

## Novo arquivo em backup_2025-07-04_18-15-13: controles.py

## Novo arquivo em backup_2025-07-04_18-15-13: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-15-13: loading.py

## Novo arquivo em backup_2025-07-04_18-15-13: menu.py

## Novo arquivo em backup_2025-07-04_18-15-13: score_manager.py

### Comparando com backup: backup_2025-07-04_18-19-35

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-19-35/app.py
@@ -1,43 +1,110 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua pelo código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        # Atualiza fade out do exit handler e se estiver ativo, trava o jogo até fechar

+        if config_menu.exit_handler.update_fade_out():

+            # fade rolando e no fim fecha o jogo, não processa eventos

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            # Se o menu exit_handler está ativo, ele consome todos os eventos

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+

+            if event.type == pygame.QUIT:

+                # Ao tentar fechar pelo botão X, abre menu sair

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-19-35/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-19-35/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-19-35: button.py

## Novo arquivo em backup_2025-07-04_18-19-35: click_effect.py

## Novo arquivo em backup_2025-07-04_18-19-35: config.py

## Novo arquivo em backup_2025-07-04_18-19-35: controles.py

## Novo arquivo em backup_2025-07-04_18-19-35: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-19-35: loading.py

## Novo arquivo em backup_2025-07-04_18-19-35: menu.py

## Novo arquivo em backup_2025-07-04_18-19-35: score_manager.py

### Comparando com backup: backup_2025-07-04_18-20-06

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-20-06/app.py
@@ -1,43 +1,110 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua pelo código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        # Atualiza fade out do exit handler e se estiver ativo, trava o jogo até fechar

+        if config_menu.exit_handler.update_fade_out():

+            # fade rolando e no fim fecha o jogo, não processa eventos

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            # Se o menu exit_handler está ativo, ele consome todos os eventos

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+

+            if event.type == pygame.QUIT:

+                # Ao tentar fechar pelo botão X, abre menu sair

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-20-06/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-20-06/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-20-06: button.py

## Novo arquivo em backup_2025-07-04_18-20-06: click_effect.py

## Novo arquivo em backup_2025-07-04_18-20-06: config.py

## Novo arquivo em backup_2025-07-04_18-20-06: controles.py

## Novo arquivo em backup_2025-07-04_18-20-06: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-20-06: loading.py

## Novo arquivo em backup_2025-07-04_18-20-06: menu.py

## Novo arquivo em backup_2025-07-04_18-20-06: score_manager.py

### Comparando com backup: backup_2025-07-04_18-20-59

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-20-59/app.py
@@ -1,43 +1,110 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua pelo código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        # Atualiza fade out do exit handler e se estiver ativo, trava o jogo até fechar

+        if config_menu.exit_handler.update_fade_out():

+            # fade rolando e no fim fecha o jogo, não processa eventos

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            # Se o menu exit_handler está ativo, ele consome todos os eventos

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+

+            if event.type == pygame.QUIT:

+                # Ao tentar fechar pelo botão X, abre menu sair

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-20-59/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-20-59/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-20-59: button.py

## Novo arquivo em backup_2025-07-04_18-20-59: click_effect.py

## Novo arquivo em backup_2025-07-04_18-20-59: config.py

## Novo arquivo em backup_2025-07-04_18-20-59: controles.py

## Novo arquivo em backup_2025-07-04_18-20-59: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-20-59: loading.py

## Novo arquivo em backup_2025-07-04_18-20-59: menu.py

## Novo arquivo em backup_2025-07-04_18-20-59: score_manager.py

### Comparando com backup: backup_2025-07-04_18-21-10

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-21-10/app.py
@@ -1,43 +1,110 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    # Simula carregamento com atualizações na tela de loading (sem backup)

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)  # Simula delay, substitua pelo código real

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        # Atualiza fade out do exit handler e se estiver ativo, trava o jogo até fechar

+        if config_menu.exit_handler.update_fade_out():

+            # fade rolando e no fim fecha o jogo, não processa eventos

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            # Se o menu exit_handler está ativo, ele consome todos os eventos

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue  # evento consumido pelo menu, ignora o resto

+

+            if event.type == pygame.QUIT:

+                # Ao tentar fechar pelo botão X, abre menu sair

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-21-10/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-21-10/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-21-10: button.py

## Novo arquivo em backup_2025-07-04_18-21-10: click_effect.py

## Novo arquivo em backup_2025-07-04_18-21-10: config.py

## Novo arquivo em backup_2025-07-04_18-21-10: controles.py

## Novo arquivo em backup_2025-07-04_18-21-10: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-21-10: loading.py

## Novo arquivo em backup_2025-07-04_18-21-10: menu.py

## Novo arquivo em backup_2025-07-04_18-21-10: score_manager.py

### Comparando com backup: backup_2025-07-04_18-25-09

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-25-09/app.py
@@ -1,43 +1,107 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [("Carregando imagens...", 50), ("Inicializando menus...", 80), ("Quase lá...", 95), ("Concluído!", 100)]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    effects = []

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        if config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effects.append(ClickEffect(event.pos[0], event.pos[1]))

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Efeitos +1

+        for effect in effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-25-09/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-25-09/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-25-09: button.py

## Novo arquivo em backup_2025-07-04_18-25-09: click_effect.py

## Novo arquivo em backup_2025-07-04_18-25-09: config.py

## Novo arquivo em backup_2025-07-04_18-25-09: controles.py

## Novo arquivo em backup_2025-07-04_18-25-09: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-25-09: loading.py

## Novo arquivo em backup_2025-07-04_18-25-09: menu.py

## Novo arquivo em backup_2025-07-04_18-25-09: score_manager.py

### Comparando com backup: backup_2025-07-04_18-26-15

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-26-15/app.py
@@ -1,43 +1,107 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [("Carregando imagens...", 50), ("Inicializando menus...", 80), ("Quase lá...", 95), ("Concluído!", 100)]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    effects = []

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        if config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effects.append(ClickEffect(event.pos[0], event.pos[1]))

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Efeitos +1

+        for effect in effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-26-15/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-26-15/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-26-15: button.py

## Novo arquivo em backup_2025-07-04_18-26-15: click_effect.py

## Novo arquivo em backup_2025-07-04_18-26-15: config.py

## Novo arquivo em backup_2025-07-04_18-26-15: controles.py

## Novo arquivo em backup_2025-07-04_18-26-15: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-26-15: loading.py

## Novo arquivo em backup_2025-07-04_18-26-15: menu.py

## Novo arquivo em backup_2025-07-04_18-26-15: score_manager.py

### Comparando com backup: backup_2025-07-04_18-28-25

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-28-25/app.py
@@ -1,43 +1,107 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [("Carregando imagens...", 50), ("Inicializando menus...", 80), ("Quase lá...", 95), ("Concluído!", 100)]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    effects = []

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        if config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effects.append(ClickEffect(event.pos[0], event.pos[1]))

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Efeitos +1

+        for effect in effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-28-25/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-28-25/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-28-25: button.py

## Novo arquivo em backup_2025-07-04_18-28-25: click_effect.py

## Novo arquivo em backup_2025-07-04_18-28-25: config.py

## Novo arquivo em backup_2025-07-04_18-28-25: controles.py

## Novo arquivo em backup_2025-07-04_18-28-25: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-28-25: loading.py

## Novo arquivo em backup_2025-07-04_18-28-25: menu.py

## Novo arquivo em backup_2025-07-04_18-28-25: score_manager.py

### Comparando com backup: backup_2025-07-04_18-29-50

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-29-50/app.py
@@ -1,43 +1,107 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [("Carregando imagens...", 50), ("Inicializando menus...", 80), ("Quase lá...", 95), ("Concluído!", 100)]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    effects = []

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        if config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effects.append(ClickEffect(event.pos[0], event.pos[1]))

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Efeitos +1

+        for effect in effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-29-50/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-29-50/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-29-50: button.py

## Novo arquivo em backup_2025-07-04_18-29-50: click_effect.py

## Novo arquivo em backup_2025-07-04_18-29-50: config.py

## Novo arquivo em backup_2025-07-04_18-29-50: controles.py

## Novo arquivo em backup_2025-07-04_18-29-50: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-29-50: loading.py

## Novo arquivo em backup_2025-07-04_18-29-50: menu.py

## Novo arquivo em backup_2025-07-04_18-29-50: score_manager.py

### Comparando com backup: backup_2025-07-04_18-30-31

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-30-31/app.py
@@ -1,43 +1,107 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [("Carregando imagens...", 50), ("Inicializando menus...", 80), ("Quase lá...", 95), ("Concluído!", 100)]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    effects = []

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        if config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effects.append(ClickEffect(event.pos[0], event.pos[1]))

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Efeitos +1

+        for effect in effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-30-31/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-30-31/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-30-31: button.py

## Novo arquivo em backup_2025-07-04_18-30-31: click_effect.py

## Novo arquivo em backup_2025-07-04_18-30-31: config.py

## Novo arquivo em backup_2025-07-04_18-30-31: controles.py

## Novo arquivo em backup_2025-07-04_18-30-31: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-30-31: loading.py

## Novo arquivo em backup_2025-07-04_18-30-31: menu.py

## Novo arquivo em backup_2025-07-04_18-30-31: score_manager.py

### Comparando com backup: backup_2025-07-04_18-31-04

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-31-04/app.py
@@ -1,43 +1,107 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [("Carregando imagens...", 50), ("Inicializando menus...", 80), ("Quase lá...", 95), ("Concluído!", 100)]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    effects = []

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        if config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effects.append(ClickEffect(event.pos[0], event.pos[1]))

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Efeitos +1

+        for effect in effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-31-04/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-31-04/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-31-04: button.py

## Novo arquivo em backup_2025-07-04_18-31-04: click_effect.py

## Novo arquivo em backup_2025-07-04_18-31-04: config.py

## Novo arquivo em backup_2025-07-04_18-31-04: controles.py

## Novo arquivo em backup_2025-07-04_18-31-04: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-31-04: loading.py

## Novo arquivo em backup_2025-07-04_18-31-04: menu.py

## Novo arquivo em backup_2025-07-04_18-31-04: score_manager.py

### Comparando com backup: backup_2025-07-04_18-31-50

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-31-50/app.py
@@ -1,43 +1,107 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [("Carregando imagens...", 50), ("Inicializando menus...", 80), ("Quase lá...", 95), ("Concluído!", 100)]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    effects = []

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        if config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effects.append(ClickEffect(event.pos[0], event.pos[1]))

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Efeitos +1

+        for effect in effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-31-50/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-31-50/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-31-50: button.py

## Novo arquivo em backup_2025-07-04_18-31-50: click_effect.py

## Novo arquivo em backup_2025-07-04_18-31-50: config.py

## Novo arquivo em backup_2025-07-04_18-31-50: controles.py

## Novo arquivo em backup_2025-07-04_18-31-50: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-31-50: loading.py

## Novo arquivo em backup_2025-07-04_18-31-50: menu.py

## Novo arquivo em backup_2025-07-04_18-31-50: score_manager.py

### Comparando com backup: backup_2025-07-04_18-32-42

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-32-42/app.py
@@ -1,43 +1,118 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+

+    steps = [

+        ("Carregando imagens...", 50),

+        ("Inicializando menus...", 80),

+        ("Quase lá...", 95),

+        ("Concluído!", 100)

+    ]

+

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    effects = []

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        # Atualiza fade out do exit handler

+        if config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        # Garante que não está pressionando múltiplos botões ao mesmo tempo

+                        pressed = pygame.mouse.get_pressed()

+                        if sum(pressed) == 1:  # Apenas um botão pressionado

+                            button.click()

+                            score += 1

+                            effects.append(ClickEffect(event.pos[0], event.pos[1]))

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        # Atualiza e desenha efeitos de "+1"

+        for effect in effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                effects.remove(effect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-32-42/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-32-42/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-32-42: button.py

## Novo arquivo em backup_2025-07-04_18-32-42: click_effect.py

## Novo arquivo em backup_2025-07-04_18-32-42: config.py

## Novo arquivo em backup_2025-07-04_18-32-42: controles.py

## Novo arquivo em backup_2025-07-04_18-32-42: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-32-42: loading.py

## Novo arquivo em backup_2025-07-04_18-32-42: menu.py

## Novo arquivo em backup_2025-07-04_18-32-42: score_manager.py

### Comparando com backup: backup_2025-07-04_18-33-50

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-33-50/app.py
@@ -1,43 +1,107 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [("Carregando imagens...", 50), ("Inicializando menus...", 80), ("Quase lá...", 95), ("Concluído!", 100)]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    effects = []

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        if config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effects.append(ClickEffect(event.pos[0], event.pos[1]))

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Efeitos +1

+        for effect in effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-33-50/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-33-50/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-33-50: button.py

## Novo arquivo em backup_2025-07-04_18-33-50: click_effect.py

## Novo arquivo em backup_2025-07-04_18-33-50: config.py

## Novo arquivo em backup_2025-07-04_18-33-50: controles.py

## Novo arquivo em backup_2025-07-04_18-33-50: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-33-50: loading.py

## Novo arquivo em backup_2025-07-04_18-33-50: menu.py

## Novo arquivo em backup_2025-07-04_18-33-50: score_manager.py

### Comparando com backup: backup_2025-07-04_18-36-22

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-36-22/app.py
@@ -1,43 +1,107 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [("Carregando imagens...", 50), ("Inicializando menus...", 80), ("Quase lá...", 95), ("Concluído!", 100)]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    effects = []

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        if config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effects.append(ClickEffect(event.pos[0], event.pos[1]))

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Efeitos +1

+        for effect in effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-36-22/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-36-22/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-36-22: button.py

## Novo arquivo em backup_2025-07-04_18-36-22: click_effect.py

## Novo arquivo em backup_2025-07-04_18-36-22: config.py

## Novo arquivo em backup_2025-07-04_18-36-22: controles.py

## Novo arquivo em backup_2025-07-04_18-36-22: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-36-22: loading.py

## Novo arquivo em backup_2025-07-04_18-36-22: menu.py

## Novo arquivo em backup_2025-07-04_18-36-22: score_manager.py

### Comparando com backup: backup_2025-07-04_18-37-00

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-37-00/app.py
@@ -1,43 +1,107 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [("Carregando imagens...", 50), ("Inicializando menus...", 80), ("Quase lá...", 95), ("Concluído!", 100)]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    effects = []

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        if config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effects.append(ClickEffect(event.pos[0], event.pos[1]))

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Efeitos +1

+        for effect in effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-37-00/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-37-00/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-37-00: button.py

## Novo arquivo em backup_2025-07-04_18-37-00: click_effect.py

## Novo arquivo em backup_2025-07-04_18-37-00: config.py

## Novo arquivo em backup_2025-07-04_18-37-00: controles.py

## Novo arquivo em backup_2025-07-04_18-37-00: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-37-00: loading.py

## Novo arquivo em backup_2025-07-04_18-37-00: menu.py

## Novo arquivo em backup_2025-07-04_18-37-00: score_manager.py

### Comparando com backup: backup_2025-07-04_18-37-59

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-37-59/app.py
@@ -1,43 +1,107 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [("Carregando imagens...", 50), ("Inicializando menus...", 80), ("Quase lá...", 95), ("Concluído!", 100)]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    effects = []

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        if config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effects.append(ClickEffect(event.pos[0], event.pos[1]))

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Efeitos +1

+        for effect in effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-37-59/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-37-59/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-37-59: button.py

## Novo arquivo em backup_2025-07-04_18-37-59: click_effect.py

## Novo arquivo em backup_2025-07-04_18-37-59: config.py

## Novo arquivo em backup_2025-07-04_18-37-59: controles.py

## Novo arquivo em backup_2025-07-04_18-37-59: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-37-59: loading.py

## Novo arquivo em backup_2025-07-04_18-37-59: menu.py

## Novo arquivo em backup_2025-07-04_18-37-59: score_manager.py

### Comparando com backup: backup_2025-07-04_18-38-40

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-38-40/app.py
@@ -1,43 +1,107 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [("Carregando imagens...", 50), ("Inicializando menus...", 80), ("Quase lá...", 95), ("Concluído!", 100)]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    effects = []

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        if config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effects.append(ClickEffect(event.pos[0], event.pos[1]))

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Efeitos +1

+        for effect in effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-38-40/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-38-40/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-38-40: button.py

## Novo arquivo em backup_2025-07-04_18-38-40: click_effect.py

## Novo arquivo em backup_2025-07-04_18-38-40: config.py

## Novo arquivo em backup_2025-07-04_18-38-40: controles.py

## Novo arquivo em backup_2025-07-04_18-38-40: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-38-40: loading.py

## Novo arquivo em backup_2025-07-04_18-38-40: menu.py

## Novo arquivo em backup_2025-07-04_18-38-40: score_manager.py

### Comparando com backup: backup_2025-07-04_18-39-11

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-39-11/app.py
@@ -1,43 +1,107 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [("Carregando imagens...", 50), ("Inicializando menus...", 80), ("Quase lá...", 95), ("Concluído!", 100)]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    effects = []

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        if config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effects.append(ClickEffect(event.pos[0], event.pos[1]))

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Efeitos +1

+        for effect in effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-39-11/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-39-11/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-39-11: button.py

## Novo arquivo em backup_2025-07-04_18-39-11: click_effect.py

## Novo arquivo em backup_2025-07-04_18-39-11: config.py

## Novo arquivo em backup_2025-07-04_18-39-11: controles.py

## Novo arquivo em backup_2025-07-04_18-39-11: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-39-11: loading.py

## Novo arquivo em backup_2025-07-04_18-39-11: menu.py

## Novo arquivo em backup_2025-07-04_18-39-11: score_manager.py

### Comparando com backup: backup_2025-07-04_18-41-57

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-41-57/app.py
@@ -1,43 +1,107 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [("Carregando imagens...", 50), ("Inicializando menus...", 80), ("Quase lá...", 95), ("Concluído!", 100)]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    effects = []

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        if config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effects.append(ClickEffect(event.pos[0], event.pos[1]))

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Efeitos +1

+        for effect in effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-41-57/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-41-57/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-41-57: button.py

## Novo arquivo em backup_2025-07-04_18-41-57: click_effect.py

## Novo arquivo em backup_2025-07-04_18-41-57: config.py

## Novo arquivo em backup_2025-07-04_18-41-57: controles.py

## Novo arquivo em backup_2025-07-04_18-41-57: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-41-57: loading.py

## Novo arquivo em backup_2025-07-04_18-41-57: menu.py

## Novo arquivo em backup_2025-07-04_18-41-57: score_manager.py

### Comparando com backup: backup_2025-07-04_18-43-10

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-43-10/app.py
@@ -1,43 +1,107 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [("Carregando imagens...", 50), ("Inicializando menus...", 80), ("Quase lá...", 95), ("Concluído!", 100)]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    effects = []

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        if config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effects.append(ClickEffect(event.pos[0], event.pos[1]))

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Efeitos +1

+        for effect in effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-43-10/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-43-10/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-43-10: button.py

## Novo arquivo em backup_2025-07-04_18-43-10: click_effect.py

## Novo arquivo em backup_2025-07-04_18-43-10: config.py

## Novo arquivo em backup_2025-07-04_18-43-10: controles.py

## Novo arquivo em backup_2025-07-04_18-43-10: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-43-10: loading.py

## Novo arquivo em backup_2025-07-04_18-43-10: menu.py

## Novo arquivo em backup_2025-07-04_18-43-10: score_manager.py

### Comparando com backup: backup_2025-07-04_18-45-12

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-45-12/app.py
@@ -1,43 +1,107 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [("Carregando imagens...", 50), ("Inicializando menus...", 80), ("Quase lá...", 95), ("Concluído!", 100)]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    effects = []

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        if config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effects.append(ClickEffect(event.pos[0], event.pos[1]))

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Efeitos +1

+        for effect in effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-45-12/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-45-12/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-45-12: button.py

## Novo arquivo em backup_2025-07-04_18-45-12: click_effect.py

## Novo arquivo em backup_2025-07-04_18-45-12: config.py

## Novo arquivo em backup_2025-07-04_18-45-12: controles.py

## Novo arquivo em backup_2025-07-04_18-45-12: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-45-12: loading.py

## Novo arquivo em backup_2025-07-04_18-45-12: menu.py

## Novo arquivo em backup_2025-07-04_18-45-12: score_manager.py

### Comparando com backup: backup_2025-07-04_18-47-46

## Mudanças em app.py
--- backup_2025-07-03_00-31-28/app.py
+++ backup_2025-07-04_18-47-46/app.py
@@ -1,43 +1,107 @@
+import pygame

+import sys

 import os

-import shutil

-from datetime import datetime

-

-def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

-    agora = datetime.now()

-    nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

-    pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

-

-    # Cria pasta backup

-    os.makedirs(pasta_backup, exist_ok=False)

-

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

-    def ignore_backups(dir, files):

-        return ['backups'] if 'backups' in files else []

-

-    shutil.copytree(pasta_origem, pasta_backup, dirs_exist_ok=True, ignore=ignore_backups)

-

-    print(f"Backup criado em: {pasta_backup}")

-    return pasta_backup

+from backup import fazer_backup

+from background import draw_background, WIDTH, HEIGHT

+from button import AnimatedButton

+from score_manager import ScoreManager

+from menu import ConfigMenu

+from loading import LoadingScreen

+from click_effect import ClickEffect

 

 def main():

-    # Define os caminhos

     pasta_do_projeto = os.path.dirname(os.path.abspath(__file__))

-    pasta_de_backups = r"C:\Users\pyetr\OneDrive\Desktop\backups"

-

-    # Faz backup no início do app

+    pasta_de_backups = os.path.join(pasta_do_projeto, "backups")

     fazer_backup(pasta_do_projeto, pasta_de_backups)

 

-    # Aqui começa o código real do seu app

-    print("App iniciado!")

-    # Coloque seu código principal aqui

+    pygame.init()

+    screen = pygame.display.set_mode((WIDTH, HEIGHT))

+    pygame.display.set_caption("Just Another Generic Clicker Game, But With References")

 

-    # Simulação de app rodando (para demo)

-    while True:

-        cmd = input("Digite 'sair' para fechar: ")

-        if cmd.strip().lower() == 'sair':

-            break

+    # Tela de loading

+    loading_screen = LoadingScreen(screen, WIDTH, HEIGHT)

+    steps = [("Carregando imagens...", 50), ("Inicializando menus...", 80), ("Quase lá...", 95), ("Concluído!", 100)]

+    for msg, percent in steps:

+        loading_screen.draw(percent, msg)

+        pygame.time.delay(700)

+

+    FONT = pygame.font.SysFont(None, 48)

+    TEXT_COLOR_SCORE = (40, 40, 60)

+

+    button = AnimatedButton(WIDTH // 2, HEIGHT // 2, 200, 200,

+                            "https://minecraft.wiki/images/Enchanted_Book.gif?b21c4")

+

+    score_manager = ScoreManager()

+    score, controls_visible = score_manager.load_data()

+

+    def loading_callback(percent, message):

+        loading_screen.draw(percent, message)

+

+    config_menu = ConfigMenu(screen, WIDTH, HEIGHT, loading_callback=loading_callback)

+    config_menu.controls_menu.visible = controls_visible

+

+    clock = pygame.time.Clock()

+    running = True

+    effects = []

+

+    while running:

+        mouse_pos = pygame.mouse.get_pos()

+

+        if config_menu.exit_handler.update_fade_out():

+            pygame.display.flip()

+            clock.tick(60)

+            continue

+

+        for event in pygame.event.get():

+            if config_menu.exit_handler.active:

+                config_menu.exit_handler.handle_event(event)

+                continue

+

+            if config_menu.handle_event(event):

+                continue

+

+            if event.type == pygame.QUIT:

+                config_menu.exit_handler.start()

+                continue

+

+            elif event.type == pygame.MOUSEBUTTONDOWN:

+                if config_menu.settings_menu.is_click_allowed(event.button):

+                    if button.is_clicked(event.pos):

+                        button.click()

+                        score += 1

+                        effects.append(ClickEffect(event.pos[0], event.pos[1]))

+

+            elif event.type == pygame.KEYDOWN:

+                if event.key == pygame.K_r:

+                    score = 0

+

+        draw_background(screen)

+        button.draw(screen)

+

+        # Efeitos +1

+        for effect in effects[:]:

+            effect.update()

+            effect.draw(screen)

+            if effect.finished:

+                effects.remove(effect)

+

+        box_x, box_y = 20, 20

+        box_w, box_h = 220, 60

+        score_manager.draw_score_box(screen, box_x, box_y, box_w, box_h)

+

+        score_text = FONT.render(f"Pontos: {score}", True, TEXT_COLOR_SCORE)

+        score_rect = score_text.get_rect(center=(box_x + box_w // 2, box_y + box_h // 2))

+        screen.blit(score_text, score_rect)

+

+        config_menu.draw_icon()

+        config_menu.draw()

+

+        pygame.display.flip()

+        clock.tick(60)

+

+    score_manager.save_data(score, config_menu.controls_menu.visible)

+    pygame.quit()

+    sys.exit()

 

 if __name__ == "__main__":

     main()



## Mudanças em background.py
--- backup_2025-07-03_00-31-28/background.py
+++ backup_2025-07-04_18-47-46/background.py
@@ -1,15 +1,50 @@
 import pygame

+import math

+import time

 

-# RESOLUÇÃO GLOBAL

 WIDTH, HEIGHT = 1280, 720

+TILE_SIZE = 40  # tamanho do quadrado

+

+# Paleta de cores base pastel

+BASE_COLORS = [

+    (200, 230, 201),  # verde claro

+    (255, 224, 178),  # laranja claro

+    (255, 205, 210),  # rosa claro

+    (187, 222, 251),  # azul claro

+    (255, 249, 196),  # amarelo claro

+    (197, 225, 165),  # verde limão claro

+]

+

+# Criar uma grid fixa de cores base para os tiles (para não mudar toda hora)

+GRID_WIDTH = WIDTH // TILE_SIZE + 1

+GRID_HEIGHT = HEIGHT // TILE_SIZE + 1

+

+grid_colors = []

+

+for y in range(GRID_HEIGHT):

+    row = []

+    for x in range(GRID_WIDTH):

+        # Escolhe uma cor base aleatória para o tile

+        row.append(BASE_COLORS[(x + y) % len(BASE_COLORS)])

+    grid_colors.append(row)

+

+def adjust_brightness(color, factor):

+    """Ajusta o brilho da cor multiplicando cada canal RGB pelo fator (0 a 1+)."""

+    r = max(0, min(255, int(color[0] * factor)))

+    g = max(0, min(255, int(color[1] * factor)))

+    b = max(0, min(255, int(color[2] * factor)))

+    return (r, g, b)

 

 def draw_background(screen):

-    top_color = (10, 10, 50)

-    bottom_color = (40, 80, 180)

-

-    for y in range(HEIGHT):

-        ratio = y / HEIGHT

-        r = int(top_color[0] * (1 - ratio) + bottom_color[0] * ratio)

-        g = int(top_color[1] * (1 - ratio) + bottom_color[1] * ratio)

-        b = int(top_color[2] * (1 - ratio) + bottom_color[2] * ratio)

-        pygame.draw.line(screen, (r, g, b), (0, y), (WIDTH, y))

+    t = time.time()

+    # Frequência da oscilação de brilho (mais lento = menor frequência)

+    freq = 0.5  # ciclos por segundo

+    

+    for y in range(GRID_HEIGHT):

+        for x in range(GRID_WIDTH):

+            base_color = grid_colors[y][x]

+            # Calcula fator de brilho entre 0.85 e 1.15 para suavizar piscada

+            brightness = 1 + 0.15 * math.sin(2 * math.pi * freq * t + (x + y))

+            color = adjust_brightness(base_color, brightness)

+            rect = pygame.Rect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)

+            pygame.draw.rect(screen, color, rect)



## Mudanças em backup.py
--- backup_2025-07-03_00-31-28/backup.py
+++ backup_2025-07-04_18-47-46/backup.py
@@ -3,16 +3,17 @@
 from datetime import datetime

 

 def fazer_backup(pasta_origem, pasta_backup_root):

-    # Cria nome da pasta backup com data e hora

+    """

+    Faz backup da pasta_origem para pasta_backup_root/backup_YYYY-MM-DD_HH-MM-SS,

+    copiando todos os arquivos e pastas, exceto a pasta 'backups' para evitar recursão.

+    """

+

     agora = datetime.now()

     nome_pasta = agora.strftime("backup_%Y-%m-%d_%H-%M-%S")

     pasta_backup = os.path.join(pasta_backup_root, nome_pasta)

 

-    # Cria pasta backup

     os.makedirs(pasta_backup, exist_ok=False)

 

-    # Copia arquivos e pastas de pasta_origem para pasta_backup,

-    # ignorando a pasta de backups para evitar cópia cíclica

     def ignore_backups(dir, files):

         return ['backups'] if 'backups' in files else []

 



## Novo arquivo em backup_2025-07-04_18-47-46: button.py

## Novo arquivo em backup_2025-07-04_18-47-46: click_effect.py

## Novo arquivo em backup_2025-07-04_18-47-46: config.py

## Novo arquivo em backup_2025-07-04_18-47-46: controles.py

## Novo arquivo em backup_2025-07-04_18-47-46: exit_handler.py

## Novo arquivo em backup_2025-07-04_18-47-46: loading.py

## Novo arquivo em backup_2025-07-04_18-47-46: menu.py

## Novo arquivo em backup_2025-07-04_18-47-46: score_manager.py
